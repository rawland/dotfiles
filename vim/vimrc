" A good engineer invests time in crafting his tools.
"
" Author: Roland Siegbert
"
set nocompatible
set hidden
filetype plugin indent on       " load file type plugins + indentation
syntax on
set t_Co=256                    " Explicitly tell vim terminal features

" Plugins:
call plug#begin('~/.vim/plugged')

" IDEish:
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }      " Filemanagement
Plug 'Xuyuanp/nerdtree-git-plugin'                          " ... and git
Plug 'justinmk/vim-dirvish'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --no-update-rc' }
Plug 'junegunn/fzf.vim'
Plug 'justinmk/vim-dirvish'
Plug 'majutsushi/tagbar'
Plug 'airblade/vim-gitgutter'                               " See what changed
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-unimpaired'
Plug 'kien/rainbow_parentheses.vim'
Plug 'scrooloose/syntastic'
Plug 'Yggdroot/indentLine'
Plug 'junegunn/vim-easy-align'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'godlygeek/tabular'
Plug 'skammer/vim-css-color', { 'for': 'css' }
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'kien/tabman.vim', { 'on': 'TMToggle' }
Plug 'tpope/vim-surround'
"Plug 'rscircus/vim-fortress'
"Plug 'plasticboy/vim-markdown'
Plug 'rscircus/vim-markdown'
Plug 'christoomey/vim-tmux-navigator'
"Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'mtth/scratch.vim'
Plug 'vim-ctrlspace/vim-ctrlspace'
Plug 'lukaszkorecki/workflowish'
Plug 'paradigm/vim-multicursor'

Plug 'severin-lemaignan/vim-minimap'
Plug 'esneider/YUNOcommit.vim'
"Plug 'gorodinskiy/vim-coloresque'
Plug 'chrisbra/Colorizer'
Plug 'moll/vim-bbye'
Plug 'vim-scripts/EasyMotion'
Plug 'mileszs/ack.vim'                                     " Ack
"  NVIM:
if has('lua')
Plug 'Shougo/neocomplete.vim'                              " note: needs if_lua
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
endif
Plug 'jeetsukumaran/vim-buffergator'
Plug 'sjl/gundo.vim'                                       " GundoToggle
Plug 'tpope/vim-obsession'                                 " Obession

" File Manager:
Plug 'lpenz/vimcommander'

" Automatic indentation settings:
Plug 'tpope/vim-sleuth'

" Writing:
Plug 'reedes/vim-wordy'
Plug 'junegunn/limelight.vim'
Plug 'lervag/vimtex', {'for': 'tex'}
"Plug 'junegunn/vim-emoji' " Doesn't work nicely. gnome-terminal doesn't support TC
"install vim-lexical when you need to, one day...

" orga:
Plug 'vim-scripts/todo-txt.vim'
Plug 'vimoutliner/vimoutliner', {'for': 'otl'}
Plug 'rscircus/taskpaper.vim', {'for': 'taskpaper'}
Plug 'dhruvasagar/vim-dotoo'
Plug 'vim-voom/VOoM'
Plug 'itchyny/calendar.vim'
Plug 'tpope/vim-speeddating'
Plug 'chrisbra/NrrwRgn'
" Plug 'Rykka/riv.vim' "Doubled loading time

" Color schemes:
Plug 'larssmit/vim-getafe'
Plug 'morhetz/gruvbox'
Plug 'brendonrapp/smyck-vim'
Plug 'reedes/vim-colors-pencil'
Plug 'nanotech/jellybeans.vim'
Plug 'Lokaltog/vim-distinguished'
Plug 'rscircus/vim-lucius'
Plug 'rscircus/summerfruit256.vim'
Plug 'rscircus/vim-tomorrow-theme'
Plug 'junegunn/seoul256.vim'
Plug 'NLKNguyen/papercolor-theme'
Plug 'sjl/badwolf'
Plug 'gosukiwi/vim-atom-dark'
Plug 'lloeki/vim-one-colorschemes'
Plug 'w0ng/vim-hybrid'
Plug 'marcopaganini/termschool-vim-theme'
Plug 'jacoborus/tender.vim'

" Distraction free writing:
Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }
Plug 'reedes/vim-pencil'

" Dev
Plug 'ryanoasis/vim-devicons'

call plug#end()

let mapleader = ","
let maplocalleader = "\<Space>"

"" General vim options:
set shell=/bin/bash
"set encoding=utf-8
set fileformats=unix,mac,dos " in this order supported file types
set t_ut=                    " This took me quite a while
set showcmd                  " display incomplete commands
set scrolloff=3              " min lines above or below cursor
set visualbell               " I hate the acoustic bell
if has('persistent_undo')
    set undofile             " creates a <FILENAME>.un~ for eternal editing
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif
set nofoldenable           " Folding
set foldmarker=#--,--#
set foldmethod=marker
set foldlevel=0
set clipboard=unnamed        " yank and paste with the system clipboard
set splitright               " split windows always vertically
au FocusLost * :wall         " Save on lost focus
set lazyredraw               " performance (wait till macro finishes)

" Command history movement:
cnoremap <c-n>  <down>
cnoremap <c-p>  <up>

" Macro editing
nnoremap <leader>ma  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>

" Don't lose selection on in/dedent:
xnoremap <  <gv
xnoremap >  >gv

" Handling Undo/Backup/Swap:
" Create ~/.vim/files if not existing
if exists('*mkdir') && !isdirectory($HOME.'/.vim/files')
  call mkdir($HOME.'/.vim/files')
  call mkdir($HOME.'/.vim/files/backup')
  call mkdir($HOME.'/.vim/files/undo')
  call mkdir($HOME.'/.vim/files/info')
endif
set backup
set backupdir   =$HOME/.vim/files/backup/
set backupext   =-vimbackup
set backupskip  =
set noswapfile "because there is git
set undofile
set undodir     =$HOME/.vim/files/undo/
" Remember things between sessions:
if has('nvim')
  set shada='100,<50,:20,%,n~/.nvim/_nviminfo
else
  set viminfo     ='100,n$HOME/.vim/files/info/viminfo
endif

if version>=703
    set relativenumber       " show line numbers from current line to calc distances
nnoremap <leader>rn :set relativenumber!<cr>
"let &colorcolumn=join(range(81,999),",") " color all columns >=81
else
    set number
    set numberwidth=5
endif

"" Control
set autoread

" GUI
set guioptions-=T            " don't show toolbar
set guioptions-=m            " don't show menubar
set guioptions-=l            " remove scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=L
set linespace=0              " no extra space between lines (!)
set mat=2                    " Blinks 10ths of seconds"
set title                    " Set terminal title

" Set cursorline in current window and normal mode
"augroup cline
"    au!
"    au WinLeave * set nocursorline
"    au WinEnter * set cursorline
"    au InsertEnter * set nocursorline
"    au InsertLeave * set cursorline
"augroup END

set ttimeout                  " Keys but not mappings (sanity!)
set ttimeoutlen=10            " Speed/Responsiveness

"" wildmenu - Ignore files you never want to edit (hopefully)
"if has("wildmenu")
set wildmenu                   " autocompletion
set wildmode=list:longest,list:full       " show all
set wildignore+=*.a,*.o
set wildignore+=*.mod "Fortran
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store
set wildignore+=*~,*.swp,*.tmp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*   " for Linux/MacOSX
"endif

set magic                      " regex

" Handle lines:
set textwidth=0
"set colorcolumn=+1
set formatoptions=qrn1
set lbr
set formatprg=par\ -q

" Enable basic mouse behavior such as resizing buffers.
set mouse=a
if exists('$TMUX')              " Support resizing in tmux
  set ttymouse=xterm2
endif

" Highlight only the lines that go past 80 characters
" augroup vimrc_autocmds
"     autocmd BufEnter * highlight OverLength ctermbg=255 guibg=#592929
"     autocmd BufEnter * match OverLength /\%79v.*/
" augroup END

"" Whitespace
set nowrap                       "No wrapping of lines per default
set autoindent                   " Keep indent, when indented
if has('breakindent')
set breakindent                  " Keep indentation, when indented & wrapped.
endif
set cindent                      " Like smartindent, but more clever
set copyindent
set smartindent                  " Helps indenting after/before specific keywords
set virtualedit=all              " Editing past line end
set backspace=indent,eol,start   " backspace through everything in insert mode
set listchars=tab:»\ ,eol:¬,extends:❯,precedes:❮,trail:▫,nbsp:▫
set fillchars=diff:⣿,vert:│
"set showbreak=↪
"set list
nnoremap <leader>tl :set list!<cr>
nnoremap <F8> :set invpaste paste?<cr>
set pastetoggle=<F2>
set showmode

"" Look and feel
syntax enable
let g:solarized_contrast="high"    "default value is normal
let g:solarized_visibilty="high"
let g:solarized_termtrans=1
let g:solarized_termcolors=256

let g:seoul256_background = 233
let g:seoul256_light_background = 256

let g:pencil_terminal_italics = 0
let g:pencil_higher_contrast_ui = 1   " 0=low (def), 1=high

"let g:PaperColor_Light_Override = { 'background' : '#abcdef', 'cursorline' : '#dfdfff', 'matchparen' : '#d6d6d6' , 'comment' : '#8e908c' }
let g:PaperColor_Light_Override = { 'background' : '#fdfdfd'} " Brighten up


"" Environment:
set background=dark

"let g:PaperColor_Light_Override = { 'background' : '#abcdef', 'cursorline' : '#dfdfff', 'matchparen' : '#d6d6d6' , 'comment' : '#8e908c' }
let g:PaperColor_Light_Override = { 'background' : '#fefefe'} " Brighten up

"" Bright Environment:
"color PaperColor
color tender

"" Dark Environment:
"color jellybeans
"color gruvbox
"color badwolf

" Do not underline CursorLine:
set cursorline                  " highlight current line
":hi CursorLine ctermbg=237 guibg=#3a3a3a cterm=none gui=none
:nnoremap <leader>H :set cursorline!<CR>

" Change background with F6
function! ToggleBackgroundColor()
  if (&background == 'light')
    set background=dark
    echo "background -> dark"
  else
    set background=light
    echo "background -> light"
  endif
endfunction
map <F6>  :call ToggleBackgroundColor()<CR>

" GUI:
if has("gui_running")
    "colorscheme seoul256-light
    color PaperColor
    set relativenumber          " show line numbers from current line to calc distances
    if has("gui_gtk2")
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types\ 11
    else
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types:h11
    endif
endif

" Searching:
noremap / /\v
vnoremap / /\v
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter`
set showmatch                   " show matches
set gdefault                    " replacing globally is default
set incsearch                   " incremental searching
set nohlsearch
nmap <leader>h :set nohlsearch!<cr>

" Toggle spell checking on and off with `,s`
let mapleader = ","
nmap <silent> <leader>s :set spell!<CR>

" Set region to British English
set spelllang=en_gb

"" Copy and paste
vmap <C-c> "+yi
vmap <C-x> "+c
vmap <C-v> c<ESC>"+p
imap <C-v> <C-r><C-o>+

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

"" Search And Replace:
" https://stackoverflow.com/questions/676600/vim-search-and-replace-selected-text
" Escape special characters in a string for exact matching.
" This is useful to copying strings from the file to the search tool
" Based on this - http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim
function! EscapeString (string)
  let string=a:string
  " Escape regex characters
  let string = escape(string, '^$.*\/~[]')
  " Escape the line endings
  let string = substitute(string, '\n', '\\n', 'g')
  return string
endfunction

" Get the current visual block for search and replaces
" This function passed the visual block through a string escape function
" Based on this - http://stackoverflow.com/questions/676600/vim-replace-selected-text/677918#677918
function! GetVisual() range
  " Save the current register and clipboard
  let reg_save = getreg('"')
  let regtype_save = getregtype('"')
  let cb_save = &clipboard
  set clipboard&

  " Put the current visual selection in the " register
  normal! ""gvy
  let selection = getreg('"')

  " Put the saved registers and clipboards back
  call setreg('"', reg_save, regtype_save)
  let &clipboard = cb_save

  "Escape any special characters in the selection
  let escaped_selection = EscapeString(selection)

  return escaped_selection
endfunction

" Start the find and replace command across the entire file
vmap <leader>z <Esc>:%s/<c-r>=GetVisual()<cr>/

"" Window movement
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

"" Buffers
map <leader>bd :Bclose<cr>
map <leader>cd :cd %:p:h<cr>
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <right> :bn<cr>
map <left> :bp<cr>

"" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

" Reasonable Buffer closure
command! Bclose call <SID>BufcloseCloseIt()
  function! <SID>BufcloseCloseIt()
     let l:currentBufNum = bufnr("%")
     let l:alternateBufNum = bufnr("#")

     if buflisted(l:alternateBufNum)
       buffer #
     else
       bnext
     endif

     if bufnr("%") == l:currentBufNum
       new
     endif

     if buflisted(l:currentBufNum)
       execute("bdelete! ".l:currentBufNum)
     endif
  endfunction

" Edit this file:
nnoremap <leader>rc <C-w><C-v><C-l>:e $MYVIMRC<cr>
nnoremap <leader>lrc <C-w><C-v><C-l>:e ~/.vimrc_local<cr>

" Exit input mode:
inoremap jk <Esc>
inoremap jj <ESC>

" Bash like keys for the command line
cnoremap <C-A> <Home>
"- collides with Riv (ReSt)
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Indent Guides:
" UTF8? ¦, ┆, or │
let g:indentLine_char = '|'
let g:indentLine_setColors = 1
let g:indentLine_enabled = 0
"let g:indentLine_color_term =  4
nnoremap <leader>ig :IndentLinesToggle<cr>
"GVim
"let g:indentLine_color_gui = '#A4E57E'

" Tagbar plugin:
let g:tagbar_usearrows = 1
let g:tagbar_indent = 1              " spaces
let g:tagbar_sort = 0                " appearance = 0, name = 1
let g:tagbar_autopreview = 0
let g:tagbar_autofocus = 0
let g:tagbar_autoclose = 0
let g:tagbar_width = 40
let g:tagbar_compact = 1
nnoremap <leader>l :TagbarToggle<CR>

" Scratch:
let g:scratch_filetype = 'markdown'
let g:scratch_persistence_file = 'scratch.vim'

" Redfine markdown tags
if executable('marktag')
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'ctagsbin' : 'marktag',
        \ 'kinds' : [
            \ 'h:header'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
            \ 'h' : 'header'
        \  },
        \ 'scope2kind' : {
            \ 'header' : 'h'
        \ }
    \ }
" Default tagbar behavior, if now marktag present
else
    let g:tagbar_type_markdown = {
      \ 'ctagstype' : 'markdown',
      \ 'kinds' : [
        \ 'h:Heading_L1',
        \ 'i:Heading_L2',
        \ 'k:Heading_L3'
      \ ]
    \ }
end

" Markdown:
"" Plasticboy:
"let g:vim_markdown_folding_disabled = 1
"let g:vim_markdown_math = 1
"let g:vim_markdown_toc_autofit = 0
"let g:vim_markdown_frontmatter = 0
"" Gabrielelana:
let g:markdown_enable_conceal = 1
let g:markdown_enable_spell_checking = 0
set conceallevel=2

" Emojis in markdown:
set completefunc=emoji#complete
augroup emoji_complete
    autocmd!
    autocmd FileType markdown setlocal completefunc=emoji#complete
augroup END

" Syntastic Plugin:
let g:syntastic_fortran_flags = '-ffree-form'
let g:syntastic_fortran_fortran_exec = 'gfortran'

"" Git Gutter:
map <leader>ggt :GitGutterToggle<cr>
map <leader>gglht :GitGutterLineHighlightsToggle<cr>
let g:gitgutter_enabled = 0
let g:gitgutter_highlight_lines = 0
let g:gitgutter_grep_command = 'rg --color=never -e'

" TaskPaper:
:let g:notes_directories = ['~/usr/cld/orga/notes']
:let g:notes_suffix = '.note'

"" TextBubbling:
" single line
nmap <C-Up> ddkP
nmap <C-Down> ddp
" multi line
vmap <C-Up> xkP`[V`]
vmap <C-Down> xp`[V`]

"" CtrlSpace:
let g:CtrlSpaceSymbols = { "File": "◯", "CTab": "▣", "Tabs": "▢" }
let g:CtrlSpaceSearchTiming = 500
let g:CtrlSpaceLoadLastWorkspaceOnStart = 1
let g:CtrlSpaceSaveWorkspaceOnSwitch = 1
let g:CtrlSpaceSaveWorkspaceOnExit = 1
if executable("rg")
  let g:CtrlSpaceGlobCommand = 'rg -g ""'
elseif executable("ag")
  let g:CtrlSpaceGlobCommand = 'ag -l --nocolor -g ""'
endif
hi link CtrlSpaceNormal   PMenu
hi link CtrlSpaceSelected PMenuSel
hi link CtrlSpaceSearch   Search
hi link CtrlSpaceStatus   StatusLine

"" CtrlP:
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_match_window_bottom = 0
let g:ctrlp_match_window_reversed = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_dotfiles = 0
let g:ctrlp_switch_buffer = 0
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)|\v[\/]html$\',
  \ 'file': '\v\.(exe|o|so|dll)$',
  \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
  \ }
if has("python")
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif

" FASTER!
if executable('rg')
" https://medium.com/@crashybang/supercharge-vim-with-fzf-and-ripgrep-d4661fc853d2#.5skvm9ypm
  command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
  " Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
  set grepprg=rg\ --color=never
  " Use ag in CtrlP for listing files. Lightning fast, respects .gitignore
  " and .agignore. Ignores hidden files by default.
  let g:ctrlp_user_command = 'rg %s --files -g ""'
elseif executable('ag')
  " Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
  set grepprg=ag\ --nogroup\ --nocolor
  " Use ag in CtrlP for listing files. Lightning fast, respects .gitignore
  " and .agignore. Ignores hidden files by default.
  let g:ctrlp_user_command = 'ag %s -l --nocolor -f -g ""'
else
  "ctrl+p ignore files in .gitignore
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
endif

" CtrlP auto cache clearing.
" ----------------------------------------------------------------------------
function! SetupCtrlP()
  if exists("g:loaded_ctrlp") && g:loaded_ctrlp
    augroup CtrlPExtension
      autocmd!
      autocmd FocusGained  * CtrlPClearCache
      autocmd BufWritePost * CtrlPClearCache
    augroup END
  endif
endfunction
if has("autocmd")
  autocmd VimEnter * :call SetupCtrlP()
endif


:nmap <leader>tf :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
:nmap <leader>tc :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>
:nmap <leader>tM :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>
:nmap <leader>tm :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>


"" Airline:
set laststatus=2
let g:airline#extensions#syntastic#enabled = 1
let g:airline_extensions = ['branch','tabline']
let g:airline_theme='sol'
let g:airline_exclude_preview = 1                " via :help ctrlspace
let g:airline#extensions#tabline#fnamemod = ':t' " Show just the filename
let g:airline_powerline_fonts = 1
" reset airline symbols
"  if !exists('g:airline_symbols')
"    let g:airline_symbols = {}
"  endif
"
"" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_linecolumn_prefix = '␊ '
"let g:airline_linecolumn_prefix = '␤ '
"let g:airline_linecolumn_prefix = '¶ '
"let g:airline_fugitive_prefix = '⎇ '
"let g:airline_paste_symbol = 'ρ'
"let g:airline_paste_symbol = 'Þ'
"let g:airline_paste_symbol = '∥'


""" Buffergator:
let g:buffergator_sort_regime = 'basename'
let g:buffergator_autoupdate = 1
let g:buffergator_show_full_directory_path = 0
let g:buffergator_vsplit_size = 25


"" NERDTree:
map <leader>nn :NERDTreeToggle<cr>
map <leader>nb :NERDTreeFromBookmark<cr>
map <leader>nf :NERDTreeFind<cr>
let g:NERDTreeDirArrowExpandable = ''
let g:NERDTreeDirArrowCollapsible = ''
let NERDTreeIgnore=['\~$', '\.pyc']
let NERDTreeRespectWildIgnore=1
let NERDTreeWinSize = 25

"" Rainbow Parentheses:
map <leader>r :RainbowParenthesesToggle<cr>
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

"" autoreload vimrc - you might want to change that line
autocmd! BufWritePost $MYVIMRC source $MYVIMRC

"" XNS
au BufNewFile,BufRead *.less set filetype=less

"" Fortran
let fortran_dialect = 'f90'
let fortran_fixed_source = 0
let fortran_free_source = 1
let fortran_more_precise = 1
let b:fortran_dialect="f.90"
hi link fortranTab NONE
au BufRead,BufNewFile *.F,*.F90 set expandtab tabstop=4 shiftwidth=4 softtabstop=4 autoindent

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
" Source: https://github.com/scrooloose/nerdtree/issues/21
  function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
      if bufwinnr(t:NERDTreeBufName) != -1
        if winnr("$") == 1
          q
        endif
      endif
    endif
  endfunction

" Close NERDTree if it is the last buffer open
autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()

"" Goyo:
nnoremap <leader>G :Goyo<cr>

" Remove trailing whitespace
" http://vim.wikia.com/wiki/Remove_unwanted_spaces
  function! StripTrailingWhitespace()
      if !&binary && &filetype != 'diff'
          normal mz
          normal Hmy
          %s/\s\+$//e
          normal 'yz<CR>
          normal `z
          retab
      endif
  endfunction
nmap <leader>tw :call StripTrailingWhitespace()<CR>

" Function to hide all the text except for the text selected in visual mode.
" This is great for highlighting parts of the code. Just call the function
" again to deselect everything.
  function! ToggleSelected(visual) range
      highlight HideSelected ctermfg=bg ctermbg=bg
                           \ guifg=bg guibg=bg gui=none term=none cterm=none

      if exists("g:toggle_selected_hide")
          call matchdelete(g:toggle_selected_hide)

          unlet g:toggle_selected_hide
          redraw

          if !a:visual
              return
          endif
      endif

      let [lnum1, col1] = getpos("'<")[1:2]
      let [lnum2, col2] = getpos("'>")[1:2]

      let pattern = '\%^\|\%<'.lnum1.'l\|\%<'.col1.'v\|\%>'.lnum2.'l\|\%>'.col2.'v'
      let g:toggle_selected_hide = matchadd('HideSelected', pattern, 1000)

      redraw
  endfunction

" Show only selected in Visual Mode
nmap <silent> <leader>th :cal ToggleSelected(0)<CR>
vmap <silent> <leader>th :cal ToggleSelected(1)<CR>

""" Switch case from UPPER, lower, Title Case
  function! TwiddleCase(str)
    if a:str ==# toupper(a:str)
      let result = tolower(a:str)
    elseif a:str ==# tolower(a:str)
  "    let result = substitute(a:str,'\C\<\([A\-ZÀ\-Ý]\){1,3}\([A\-ZÀ\-Ý]\+\)\>', '\u\1\L\2', 'g')
      let result = substitute(a:str,'\(\<\w\{4,60}\>\)', '\u\1', 'g')
   else
      let result = toupper(a:str)
    endif
    return result
  endfunction

vnoremap ~ y:call setreg('', TwiddleCase(@"), getregtype(''))<CR>gv""Pgv

" Autoremove white trailing white space:
" autocmd BufWritePre * :%s/\s\+$//e

" Easy-align:
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <Leader>aip)
"nmap <Leader>a <Plug>(EasyAlign)

let g:easy_align_delimiters = {
\':': { 'pattern': '::\|:',
\'left_margin': 1,
\'right_margin': 1,
\'stick_to_left': 0 } }

" TabMan - Toggle:
map <leader>ttm :TMToggle<cr>

" Minimap
map <leader>mm :Minimap<cr>
let g:minimap_highlight='Visual'

" Fix wandering along wrapped lines:
nmap j gj
nmap k gk
nmap <leader>wrap :setlocal wrap!<cr>:setlocal wrap?<cr>

" Colorizer:
let g:colorizer_auto_filetype='css,less,html'

" Orgahelp:
nnoremap <leader>mv ddGp` "move current line to the end of buffer without moving cursor
nnoremap <leader>cp YGp`  "copy current line to the end of buffer without moving cursor
nmap <F7> a<C-R>=strftime("%Y-%m-%d %a %H:%M")<CR><Esc>
imap <F7> <C-R>=strftime("%Y-%m-%d %a %H:%M")<CR>

" Switch between the last two files
nnoremap <leader><leader> <c-^>

" Tab wrapper
"  function! InsertTabWrapper()
"      let col = col('.') - 1
"      if !col || getline('.')[col - 1] !~ '\k'
"         return "\<tab>"
"      else
"         return "\<c-p>"
"      endif
"  endfunction
"inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
"inoremap <S-Tab> <c-n>

" Use one space, not two, after punctuation.
set nojoinspaces

" When editing a file, always jump to the last known cursor position.
" Don't do it for commit messages, when the position is invalid, or when
" inside an event handler (happens when dropping a file on gvim).
augroup vimrcEx
  autocmd!

  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
augroup END

" Markdown:
" augroup WrapLineInMarkdownFile
"     autocmd!
"     autocmd FileType markdown setlocal wrap
" augroup END
"autocmd BufEnter *.md set updatetime=500

" When the type of shell script is /bin/sh, assume a POSIX-compatible
" shell for syntax highlighting purposes.
let g:is_posix = 1

" Autocomplete with dictionary words when spell check is on
set complete+=kspell

" Always use vertical diffs
set diffopt+=vertical

" Local adaptations:
if filereadable($HOME . "/.vimrc_local")
  source ~/.vimrc_local
endif

" " todo.txt:
" " Use todo#complete as the omni complete function for todo files
" au filetype todo setlocal omnifunc=todo#complete
" " Auto complete projects
" au filetype todo imap <buffer> + +<C-X><C-O>
" " Auto complete contexts
" au filetype todo imap <buffer> @ @<C-X><C-O>

" Calendar
let g:calendar_google_calendar = 1
let g:calendar_google_task = 1

" If silver searcher present:
let g:ackprg = 'rg --vimgrep --no-heading'
let g:ack_autoclose = 1
let g:ackpreview = 1
"cnoreabbrev Ack Ack!
nnoremap <Leader>a :Ack -i<Space>


" FORTRESS:
map <leader>ff :call fortress#format()<cr>
imap <leader>ff :call fortress#format()<cr>

" NVIM:
if has('lua')
" NeoComplete:
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplete#auto_complete_delay = 200

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" NeoSnippet:
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
" For conceal markers.
"if has('conceal')
"  set conceallevel=2 concealcursor=niv
"endif

" NVIM:
endif "has('lua')

" VimCommander:
noremap <silent> <F12> :cal VimCommanderToggle()<CR>

" TmuxNavigator:
let g:tmux_navigator_save_on_switch = 2
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <c-h> :TmuxNavigateLeft<cr>
nnoremap <silent> <c-j> :TmuxNavigateDown<cr>
nnoremap <silent> <c-k> :TmuxNavigateUp<cr>
nnoremap <silent> <c-l> :TmuxNavigateRight<cr>

" Relative line numbers in a Dirvish buffer
"autocmd! FileType dirvish setlocal relativenumber

" Sources:
" https://amix.dk/vim/vimrc.html ~Amir Salihefendic
" http://stevelosh.com/blog/2010/09/coming-home-to-vim/ ~Steve Losh
" https://github.com/greg0ire/more-instantly-better-vim ~Dammian Conway
" https://gist.github.com/1470884
" https://gist.github.com/1471147
" https://gist.github.com/2424873
