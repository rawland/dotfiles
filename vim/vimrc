" A good engineer invests time in crafting his tools.

" Author: Roland Siegbert
"
set nocompatible
set hidden
filetype plugin indent on       " load file type plugins + indentation
syntax on
set t_Co=256                    " Explicitly tell vim terminal features

"if $COLORTERM == 'gnome-terminal'
"    set term=xterm-256color
"endif

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Plugins: {{{
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
call plug#begin('~/.vim/plugged')


" IDEish:
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }      " Filemanagement
Plug 'Xuyuanp/nerdtree-git-plugin'                          " ... and git
Plug 'justinmk/vim-dirvish'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --no-update-rc' }
Plug 'junegunn/fzf.vim'
Plug 'majutsushi/tagbar'
Plug 'ludovicchabant/vim-gutentags'                         " Automatic (c)tag file generation
Plug 'airblade/vim-gitgutter'                               " See what changed
Plug 'tpope/vim-fugitive'
Plug 'jreybert/vimagit'
Plug 'tpope/vim-unimpaired'
Plug 'kien/rainbow_parentheses.vim'
"Plug 'scrooloose/syntastic'
Plug 'Yggdroot/indentLine'
Plug 'junegunn/vim-easy-align'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'godlygeek/tabular'
Plug 'skammer/vim-css-color', { 'for': 'css' }
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'kien/tabman.vim', { 'on': 'TMToggle' }
Plug 'tpope/vim-surround'
"Plug 'rscircus/vim-fortress'
Plug 'plasticboy/vim-markdown'
Plug 'iamcco/mathjax-support-for-mkdp'
Plug 'iamcco/markdown-preview.vim'
"Plug 'MikeCoder/markdown-preview.vim'
"Plug 'rscircus/vim-markdown'
Plug 'christoomey/vim-tmux-navigator'
"Plug 'tmux-plugins/vim-tmux-focus-events'
Plug 'mtth/scratch.vim'
Plug 'vim-ctrlspace/vim-ctrlspace'
Plug 'lukaszkorecki/workflowish'
Plug 'paradigm/vim-multicursor'
Plug 'mhinz/vim-startify'
Plug 'junegunn/gv.vim'
Plug 'junegunn/vim-slash'
Plug 'djoshea/vim-autoread'
Plug 'git-time-metric/gtm-vim-plugin'                      " git-time-metric
Plug 'severin-lemaignan/vim-minimap'
Plug 'esneider/YUNOcommit.vim'
"Plug 'gorodinskiy/vim-coloresque'
Plug 'chrisbra/Colorizer'
Plug 'moll/vim-bbye'
Plug 'easymotion/vim-easymotion'
Plug 'mileszs/ack.vim'                                     " Ack
"  NVIM:
if has('lua')
"  Plug 'Shougo/neocomplete.vim'                              " note: needs if_lua
"  Plug 'Shougo/neosnippet.vim'
"  Plug 'Shougo/neosnippet-snippets'
endif
Plug 'ajh17/VimCompletesMe'
Plug 'sjl/gundo.vim'                                       " GundoToggle
Plug 'tpope/vim-obsession'                                 " Obession
"Plug 'lornix/vim-scrollbar'
Plug 'flebel/vim-scroll-position'
Plug 'gryf/zoom.vim'                                       " Zooming with CTRL-+/- and MouseWheel 

" File Manager:
Plug 'lpenz/vimcommander'

" Automatic indentation settings:
Plug 'tpope/vim-sleuth'

" Writing:
Plug 'reedes/vim-wordy', {'on': 'Wordy'}
Plug 'junegunn/limelight.vim'
Plug 'lervag/vimtex', {'for': 'tex'}
Plug 'junegunn/vim-emoji' " Doesn't work nicely. gnome-terminal doesn't support TC
"install vim-lexical when you need to, one day...

" orga:
Plug 'vim-scripts/todo-txt.vim'
" vimwikibundle: tasklib, Taskwarrior, vimwiki: - https://github.com/tbabej/taskwiki
Plug 'blindFS/vim-taskwarrior'
"Plug 'tbabej/taskwiki'
"Plug 'vimwiki/vimwiki', {'branch':'dev'}
Plug 'vimoutliner/vimoutliner', {'for': 'otl'}
Plug 'rscircus/taskpaper.vim', {'for': 'taskpaper'}
Plug 'dhruvasagar/vim-dotoo'
Plug 'vim-voom/VOoM'
Plug 'itchyny/calendar.vim'
Plug 'tpope/vim-speeddating'
Plug 'chrisbra/NrrwRgn'
" Plug 'Rykka/riv.vim' "Doubled loading time
Plug 'dbmrq/vim-ditto'

" Color schemes:
Plug 'larssmit/vim-getafe'
Plug 'morhetz/gruvbox'
Plug 'brendonrapp/smyck-vim'
Plug 'reedes/vim-colors-pencil'
Plug 'nanotech/jellybeans.vim'
Plug 'Lokaltog/vim-distinguished'
"Plug 'rscircus/vim-lucius'
Plug 'jonathanfilip/vim-lucius'
Plug 'rscircus/summerfruit256.vim'
Plug 'rscircus/vim-tomorrow-theme'
Plug 'junegunn/seoul256.vim'
Plug 'NLKNguyen/papercolor-theme'
Plug 'sjl/badwolf'
Plug 'lloeki/vim-one-colorschemes'
Plug 'w0ng/vim-hybrid'
Plug 'marcopaganini/termschool-vim-theme'
Plug 'jacoborus/tender.vim'
Plug 'vim-scripts/mayansmoke'
Plug 'therubymug/vim-pyte'
Plug 'ptrr/proton-vim'
Plug 'altercation/vim-colors-solarized'
Plug 'acarapetis/vim-colors-github'
"Plug 'dterei/VimCobaltColourScheme'
Plug 'GertjanReynaert/cobalt2-vim-theme'

" Distraction free writing:
Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }
Plug 'reedes/vim-pencil'

" Dev
Plug 'ryanoasis/vim-devicons'

call plug#end()

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Basics: }}}
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

let mapleader = ","
let maplocalleader = "\<Space>"

"" General vim options:
set shell=/bin/bash
set encoding=utf-8
set modelines=1              " Allows the usage of '" vim:foldmethod=marker:foldlevel=0' in individual files
set fileformats=unix,mac,dos " in this order supported file types
set t_ut=                    " This took me quite a while - Disable Background Color Erase
set showcmd                  " display incomplete commands
set scrolloff=3              " min lines above or below cursor
set visualbell               " I hate the acoustic bell
if has('persistent_undo')
    set undofile             " creates a <FILENAME>.un~ for eternal editing
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif
set clipboard=unnamed         " yank and paste with the system clipboard
set splitright                " split windows always vertically
au FocusLost * :wall          " Save on lost focus
set lazyredraw                " performance (wait till macro finishes)
" Folding:
set foldenable
set foldlevelstart=10         " Open all folds by default
set foldnestmax=5             " Maximum nesting
set foldmethod=marker
set relativenumber
set number

" Command history movement:
cnoremap <c-n>  <down>
cnoremap <c-p>  <up>

" Macro editing
nnoremap <leader>ma  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>

" Don't lose selection on in/dedent:
xnoremap <  <gv
xnoremap >  >gv

" Handling Undo/Backup/Swap:
" Create ~/.vim/files if not existing
if exists('*mkdir') && !isdirectory($HOME.'/.vim/files')
  call mkdir($HOME.'/.vim/files')
  call mkdir($HOME.'/.vim/files/backup')
  call mkdir($HOME.'/.vim/files/undo')
  call mkdir($HOME.'/.vim/files/info')
endif
set backup
set backupdir   =$HOME/.vim/files/backup/
set backupext   =-vimbackup
set backupskip  =
set noswapfile "because there is git
set undofile
set undodir     =$HOME/.vim/files/undo/

" Remember things between sessions:
if has('nvim')
  set shada='100,<50,:20,%,n~/.nvim/_nviminfo
else
  set viminfo     ='100,n$HOME/.vim/files/info/viminfo
endif

" Toggle between number and relativenumber
function! ToggleNumber()
    if(&relativenumber == 1)
        set norelativenumber
        set nonumber
    else
        set relativenumber
        set number
    endif
endfunc
nnoremap <leader>rn :call ToggleNumber()<cr>

" GUI
set guioptions-=T            " don't show toolbar
set guioptions-=m            " don't show menubar
set guioptions-=l            " remove scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=L
set linespace=0              " no extra space between lines (!)
set mat=2                    " Blinks 10ths of seconds"
set title                    " Set terminal title
set ttimeout                  " Keys but not mappings (sanity!)
set ttimeoutlen=10            " Speed/Responsiveness

"" wildmenu - Ignore files you never want to edit (hopefully)
set wildmenu                   " autocompletion
set wildmode=list:longest,list:full       " show all
set wildignore+=*.a,*.o
set wildignore+=*.mod "Fortran
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store
set wildignore+=*~,*.swp,*.tmp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*   " for Linux/MacOSX

set magic                      " regex

" Handle lines:
set textwidth=0
"set colorcolumn=+1
set formatoptions=qrn1
set lbr                        " Do not break lines in the middle of words
set formatprg=par\ -q

" Enable basic mouse behavior such as resizing buffers.
set mouse=a
if exists('$TMUX')              " Support resizing in tmux
  set ttymouse=xterm2
endif

" Highlight only the lines that go past 80 characters
" augroup vimrc_autocmds
"     autocmd BufEnter * highlight OverLength ctermbg=255 guibg=#592929
"     autocmd BufEnter * match OverLength /\%79v.*/
" augroup END

"" Whitespace {{{
set nowrap                       "No wrapping of lines per default
set autoindent                   " Keep indent, when indented
if has('breakindent')
  set breakindent                " Keep indentation, when indented & wrapped.
endif
set cindent                      " Like smartindent, but more clever
set copyindent
set smartindent                  " Helps indenting after/before specific keywords
"set virtualedit=all              " Editing past line end
set backspace=indent,eol,start   " backspace through everything in insert mode
set listchars=tab:›\ ,eol:¬,extends:❯,precedes:❮,trail:▫,nbsp:▫
set fillchars=diff:⣿,vert:│,fold:-
let &showbreak = '↳ '
nnoremap <leader>tl :set list!<cr>
map <leader>p :set invpaste paste?<cr>
set pastetoggle=<leader>p
set showmode
" }}}

" Abbreviations:
" Hard to type things {{{
iabbrev >> →
iabbrev << ←
iabbrev ^^ ↑
iabbrev VV ↓
iabbrev aa λ
" }}}

" Toggle folds (<Space>) {{{
nnoremap <silent> <space> :exe 'silent! normal! '.((foldclosed('.')>0)? 'zMzx' : 'zc')<CR>
" }}}

"" Environment:
set background=light

" Light Environment:
"color PaperColor
color summerfruit256

" Dark Environment:
"color badwolf

syntax enable
let g:solarized_termcolors=256

let g:seoul256_background = 233
let g:seoul256_light_background = 256

let g:pencil_terminal_italics = 1
let g:pencil_higher_contrast_ui = 0   " 0=low (def), 1=high
let g:pencil_terminal_italics = 1
let g:pencil_neutral_code_bg = 1

let g:lucius_contrast="high"

let g:gruvbox_contrast_light="hard"
let g:gruvbox_vert_split="bg2"
let g:gruvbox_italic=1

"Systematic User-Config Options:
let g:PaperColor_Theme_Options = {
      \   'theme': {
      \     'default': {
      \       'allow_bold': 1,
      \       'allow_italic': 1,
      \       'transparent_background': 0
      \     }
      \   },
      \   'language': {
      \     'python': {
      \       'highlight_builtins' : 1
      \     },
      \     'c': {
      \       'highlight_builtins' : 1
      \     },
      \     'cpp': {
      \       'highlight_standard_library': 1
      \     }
      \   }
      \ }

" Do not underline CursorLine:
set cursorline                  " highlight current line
":hi CursorLine ctermbg=237 guibg=#3a3a3a cterm=none gui=none
:nnoremap <leader>H :set cursorline!<CR>

" Change background with F6
function! ToggleBackgroundColor()
  if (&background == 'light')
    set background=dark
    echo "background -> dark"
  else
    set background=light
    echo "background -> light"
  endif
endfunction
map <F6>  :call ToggleBackgroundColor()<CR>

" GUI:
if has("gui_running")
    "colorscheme seoul256-light
    color PaperColor
    set relativenumber          " show line numbers from current line to calc distances
    if has("gui_gtk2")
"      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types\ 10
      set guifont=Input\ 11
    else
"      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types:h10
      set guifont=Input:h11
    endif
endif

" Searching:
noremap / /\v
vnoremap / /\v
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter`
set showmatch                   " show matches
set gdefault                    " replacing globally is default
set incsearch                   " incremental searching
set nohlsearch
nmap <leader>h :set nohlsearch!<cr>

" Toggle spell checking on and off with `,s`
let mapleader = ","
nmap <silent> <leader>s :set spell!<CR>

" Set region to British English
set spelllang=en_gb

"" Copy and paste
vmap <C-c> "+yi
vmap <C-x> "+c
vmap <C-v> c<ESC>"+p
imap <C-v> <C-r><C-o>+

" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %

"" Search And Replace:
" https://stackoverflow.com/questions/676600/vim-search-and-replace-selected-text
" Escape special characters in a string for exact matching.
" This is useful to copying strings from the file to the search tool
" Based on this - http://peterodding.com/code/vim/profile/autoload/xolox/escape.vim
function! EscapeString (string)
  let string=a:string
  " Escape regex characters
  let string = escape(string, '^$.*\/~[]')
  " Escape the line endings
  let string = substitute(string, '\n', '\\n', 'g')
  return string
endfunction

" Get the current visual block for search and replaces
" This function passed the visual block through a string escape function
" Based on this - http://stackoverflow.com/questions/676600/vim-replace-selected-text/677918#677918
function! GetVisual() range
  " Save the current register and clipboard
  let reg_save = getreg('"')
  let regtype_save = getregtype('"')
  let cb_save = &clipboard
  set clipboard&

  " Put the current visual selection in the " register
  normal! ""gvy
  let selection = getreg('"')

  " Put the saved registers and clipboards back
  call setreg('"', reg_save, regtype_save)
  let &clipboard = cb_save

  "Escape any special characters in the selection
  let escaped_selection = EscapeString(selection)

  return escaped_selection
endfunction

" Start the find and replace command across the entire file
vmap <leader>z <Esc>:%s/<c-r>=GetVisual()<cr>/

" FastEscape {{{
" Speed up transition from modes
if ! has('gui_running')
  set ttimeoutlen=10
  augroup FastEscape
    autocmd!
    au InsertEnter * set timeoutlen=0
    au InsertLeave * set timeoutlen=1000
  augroup END
endif
" }}}

" Close Quickfix window (,qq) {{{
map <leader>qq :cclose<CR>
" }}}

" Join lines and restore cursor location (J) {{{
nnoremap J mjJ`j
 " }}}

" Speed up viewport scrolling {{{
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>
" }}}

"" Window movement
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" Faster split resizing (+,-) {{{
if bufwinnr(1)
  map + <C-W>+
  map - <C-W>-
endif
" }}}

"" Buffers
map <leader>bd :Bclose<cr>
map <leader>cd :cd %:p:h<cr>
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <right> :bn<cr>
map <left> :bp<cr>

"" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

" Reasonable Buffer closure
command! Bclose call <SID>BufcloseCloseIt()
  function! <SID>BufcloseCloseIt()
     let l:currentBufNum = bufnr("%")
     let l:alternateBufNum = bufnr("#")

     if buflisted(l:alternateBufNum)
       buffer #
     else
       bnext
     endif

     if bufnr("%") == l:currentBufNum
       new
     endif

     if buflisted(l:currentBufNum)
       execute("bdelete! ".l:currentBufNum)
     endif
  endfunction

" Edit this file:
nnoremap <leader>rc <C-w><C-v><C-l>:e $MYVIMRC<cr>
nnoremap <leader>lrc <C-w><C-v><C-l>:e ~/.vimrc_local<cr>

" Exit input mode:
inoremap jk <Esc>
inoremap jj <ESC>

" Bash like keys for the command line
cnoremap <C-A> <Home>
"- collides with Riv (ReSt)
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Jumping to tags {{{
" Basically, <c-]> jumps to tags (like normal) and <c-\> opens the tag in a new
" split instead.
"
" Both of them will align the destination line to the upper middle part of the
" screen.  Both will pulse the cursor line so you can see where the hell you
" are.  <c-\> will also fold everything in the buffer and then unfold just
" enough for you to see the destination line.
nnoremap <c-]> <c-]>mzzvzz15<c-e>`z:Pulse<cr>
nnoremap <c-\> <c-w>v<c-]>mzzMzvzz15<c-e>`z:Pulse<cr>

" Pulse Line (thanks Steve Losh)
function! s:Pulse() " {{{
  redir => old_hi
  silent execute 'hi CursorLine'
  redir END
  let old_hi = split(old_hi, '\n')[0]
  let old_hi = substitute(old_hi, 'xxx', '', '')

  let steps = 8
  let width = 1
  let start = width
  let end = steps * width
  let color = 233

  for i in range(start, end, width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor
  for i in range(end, start, -1 * width)
    execute "hi CursorLine ctermbg=" . (color + i)
    redraw
    sleep 6m
  endfor

  execute 'hi ' . old_hi
endfunction " }}}

command! -nargs=0 Pulse call s:Pulse()
" }}}

" Word Processor Mode {{{
augroup word_processor_mode
  autocmd!

  function! WordProcessorMode() " {{{
    setlocal formatoptions=t1
    map j gj
    map k gk
    setlocal smartindent
    setlocal spell spelllang=en_gb
    setlocal noexpandtab
    setlocal wrap
    setlocal linebreak
    Goyo 100
  endfunction " }}}
  com! WP call WordProcessorMode()
augroup END
" }}}"

" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
" Plugins:
" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

" Indent Guides:
" UTF8? ¦, ┆, or │
let g:indentLine_char = '|'
let g:indentLine_setColors = 1
let g:indentLine_enabled = 1
"let g:indentLine_color_term =  4
nnoremap <leader>ig :IndentLinesToggle<cr>
"GVim
"let g:indentLine_color_gui = '#A4E57E'

" Tagbar:
let g:tagbar_usearrows = 1
let g:tagbar_indent = 1              " spaces
let g:tagbar_sort = 0                " appearance = 0, name = 1
let g:tagbar_autopreview = 0
let g:tagbar_autofocus = 0
let g:tagbar_autoclose = 0
let g:tagbar_width = 30
let g:tagbar_compact = 1
let g:tagbar_show_visibility = 1
nnoremap <leader>l :TagbarToggle<CR>

" Scratch:
let g:scratch_filetype = 'markdown'
let g:scratch_persistence_file = 'scratch.vim'

" markdown2ctags: Add support for markdown files in tagbar.
let g:tagbar_type_markdown = {
    \ 'ctagstype': 'markdown',
    \ 'ctagsbin' : '$HOME/dotfiles/utils/markdown2ctags/markdown2ctags.py',
    \ 'ctagsargs' : '-f - --sort=yes',
    \ 'kinds' : [
        \ 's:sections',
        \ 'i:images'
    \ ],
    \ 'sro' : '|',
    \ 'kind2scope' : {
        \ 's' : 'section',
    \ },
    \ 'sort': 0,
\ }

" Redfine markdown tags
"if executable('marktag')
"    let g:tagbar_type_markdown = {
"        \ 'ctagstype' : 'markdown',
"        \ 'ctagsbin' : 'marktag',
"        \ 'kinds' : [
"            \ 'h:header'
"        \ ],
"        \ 'sro' : '.',
"        \ 'kind2scope' : {
"            \ 'h' : 'header'
"        \  },
"        \ 'scope2kind' : {
"            \ 'header' : 'h'
"        \ }
"    \ }
"
"" Default tagbar behavior, if now marktag present
"else
"    let g:tagbar_type_markdown = {
"      \ 'ctagstype' : 'markdown',
"      \ 'kinds' : [
"        \ 'h:Heading_L1',
"        \ 'i:Heading_L2',
"        \ 'k:Heading_L3'
"      \ ]
"    \ }
"end

let g:tagbar_type_tex = {
    \ 'ctagstype' : 'latex',
    \ 'kinds'     : [
        \ 's:sections',
        \ 'g:graphics:1:0',
        \ 'p:pagerefs:1:0'
    \ ],
    \ 'sort'    : 0,
    \ }

" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'latex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:1:0',
"         \ 'l:labels:1:0',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0,
"     \ }

" Markdown:
"" Plasticboy:
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_math = 1
let g:vim_markdown_toc_autofit = 0
let g:vim_markdown_frontmatter = 0
let g:vim_markdown_conceal = 0
"" Gabrielelana:
"let g:markdown_enable_conceal = 1
"let g:markdown_enable_spell_checking = 0


" Syntastic Plugin:
let g:syntastic_fortran_flags = '-ffree-form'
let g:syntastic_fortran_fortran_exec = 'gfortran'

"" Git Gutter:
map <leader>ggt :GitGutterToggle<cr>
map <leader>gglht :GitGutterLineHighlightsToggle<cr>
let g:gitgutter_enabled = 1
let g:gitgutter_highlight_lines = 0
let g:gitgutter_grep_command = 'rg --color=never -e'

" TaskPaper:
:let g:notes_directories = ['~/usr/cld/orga/notes']
:let g:notes_suffix = '.note'

"" TextBubbling:
" single line
nmap <C-Up> ddkP
nmap <C-Down> ddp
" multi line
vmap <C-Up> xkP`[V`]
vmap <C-Down> xp`[V`]

"" CtrlSpace:
let g:CtrlSpaceSymbols = { "File": "◯", "CTab": "▣", "Tabs": "▢" }
let g:CtrlSpaceSearchTiming = 500
let g:CtrlSpaceLoadLastWorkspaceOnStart = 1
let g:CtrlSpaceSaveWorkspaceOnSwitch = 1
let g:CtrlSpaceSaveWorkspaceOnExit = 1
if executable("rg")
  let g:CtrlSpaceGlobCommand = 'rg -g ""'
elseif executable("ag")
  let g:CtrlSpaceGlobCommand = 'ag -l --nocolor -g ""'
endif
hi link CtrlSpaceNormal   PMenu
hi link CtrlSpaceSelected PMenuSel
hi link CtrlSpaceSearch   Search
hi link CtrlSpaceStatus   StatusLine

"" CtrlP:
nnoremap <leader>bs :CtrlPBuffer<cr>
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_match_window_bottom = 0
let g:ctrlp_match_window_reversed = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_dotfiles = 0
let g:ctrlp_switch_buffer = 0
let g:ctrlp_clear_cache_on_exit = 0
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)|\v[\/]html$\',
  \ 'file': '\v\.(exe|o|so|dll)$',
  \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
  \ }
if has("python")
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif

" FASTER!
if executable('rg')
" https://medium.com/@crashybang/supercharge-vim-with-fzf-and-ripgrep-d4661fc853d2#.5skvm9ypm
  command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>).'| tr -d "\017"', 1, <bang>0)
  " Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
  set grepprg=rg\ --color=never
  " Use ag in CtrlP for listing files. Lightning fast, respects .gitignore
  " and .agignore. Ignores hidden files by default.
  let g:ctrlp_user_command = 'rg %s --files -g ""'
elseif executable('ag')
  " Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
  set grepprg=ag\ --nogroup\ --nocolor
  " Use ag in CtrlP for listing files. Lightning fast, respects .gitignore
  " and .agignore. Ignores hidden files by default.
  let g:ctrlp_user_command = 'ag %s -l --nocolor -f -g ""'
else
  "ctrl+p ignore files in .gitignore
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
endif

" CtrlP auto cache clearing.
" ----------------------------------------------------------------------------
function! SetupCtrlP()
  if exists("g:loaded_ctrlp") && g:loaded_ctrlp
    augroup CtrlPExtension
      autocmd!
      autocmd FocusGained  * CtrlPClearCache
      autocmd BufWritePost * CtrlPClearCache
    augroup END
  endif
endfunction
if has("autocmd")
  autocmd VimEnter * :call SetupCtrlP()
endif


:nmap <leader>tf :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
:nmap <leader>tc :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>
:nmap <leader>tM :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>
:nmap <leader>tm :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>


"" Airline:
set laststatus=2
let g:airline#extensions#branch#enabled = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tagbar#enabled = 1

"let g:airline#extensions#tabline#fnamemod = ':t' " Show just the filename
let g:airline_theme='pencil'
let g:airline_exclude_preview = 1                " via :help ctrlspace
let g:airline_powerline_fonts = 1
"reset airline symbols
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif
let g:airline_symbols.space = "\ua0"

" air-line
let g:airline_powerline_fonts = 1

" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = 'emoji unicode: 25b6'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = 'emoji unicode: 25c0'
"let g:airline_symbols.linenr = '␊'
let g:airline_symbols.linenr = '␤'
"let g:airline_symbols.linenr = '¶'
"let g:airline_symbols.branch = '⎇'
"let g:airline_symbols.paste = 'ρ'
"let g:airline_symbols.paste = 'Þ'
"let g:airline_symbols.paste = '∥'
"let g:airline_symbols.whitespace = 'Ξ'

" airline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
"let g:airline_left_sep = ''
"let g:airline_left_alt_sep = ''
"let g:airline_right_sep = ''
"let g:airline_right_alt_sep = ''
"let g:airline_symbols.branch = ''
"let g:airline_symbols.readonly = ''
"let g:airline_symbols.linenr = ''

"" Git Time Metrics Airline:
function! AirlineInit()
  if exists('*GTMStatusline')
    call airline#parts#define_function('gtmstatus', 'GTMStatusline')
    let g:airline_section_b = airline#section#create([g:airline_section_b, ' ', '[', 'gtmstatus', ']'])
  endif
endfunction
autocmd User AirlineAfterInit call AirlineInit()

" Enable the status Plugin
let g:gtm_plugin_status_enabled = 1


"" NERDTree:
map <leader>nn :NERDTreeToggle<cr>
map <leader>nb :NERDTreeFromBookmark<cr>
map <leader>nf :NERDTreeFind<cr>
let g:NERDTreeDirArrowExpandable = ''
let g:NERDTreeDirArrowCollapsible = ''
let NERDTreeIgnore=['\~$', '\.pyc']
let NERDTreeRespectWildIgnore=1
let NERDTreeWinSize = 25

"" Rainbow Parentheses:
map <leader>r :RainbowParenthesesToggle<cr>
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

"" autoreload vimrc - you might want to change that line
autocmd! BufWritePost $MYVIMRC source $MYVIMRC

"" XNS
au BufNewFile,BufRead *.less set filetype=less

"" Fortran
let fortran_dialect = 'f90'
let fortran_fixed_source = 0
let fortran_free_source = 1
let fortran_more_precise = 1
let b:fortran_dialect="f.90"
hi link fortranTab NONE
au BufRead,BufNewFile *.F,*.F90 set expandtab tabstop=4 shiftwidth=4 softtabstop=4 autoindent

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
" Source: https://github.com/scrooloose/nerdtree/issues/21
  function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
      if bufwinnr(t:NERDTreeBufName) != -1
        if winnr("$") == 1
          q
        endif
      endif
    endif
  endfunction

" Close NERDTree if it is the last buffer open
autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()

"" Goyo:
nnoremap <leader>G :Goyo<cr>
let g:goyo_height='100%'
let g:goyo_width='100'

" Remove trailing whitespace
" http://vim.wikia.com/wiki/Remove_unwanted_spaces
  function! StripTrailingWhitespace()
      if !&binary && &filetype != 'diff'
          normal mz
          normal Hmy
          %s/\s\+$//e
          normal 'yz<CR>
          normal `z
          retab
      endif
  endfunction
nmap <leader>tw :call StripTrailingWhitespace()<CR>

" Function to hide all the text except for the text selected in visual mode.
" This is great for highlighting parts of the code. Just call the function
" again to deselect everything.
  function! ToggleSelected(visual) range
      highlight HideSelected ctermfg=bg ctermbg=bg
                           \ guifg=bg guibg=bg gui=none term=none cterm=none

      if exists("g:toggle_selected_hide")
          call matchdelete(g:toggle_selected_hide)

          unlet g:toggle_selected_hide
          redraw

          if !a:visual
              return
          endif
      endif

      let [lnum1, col1] = getpos("'<")[1:2]
      let [lnum2, col2] = getpos("'>")[1:2]

      let pattern = '\%^\|\%<'.lnum1.'l\|\%<'.col1.'v\|\%>'.lnum2.'l\|\%>'.col2.'v'
      let g:toggle_selected_hide = matchadd('HideSelected', pattern, 1000)

      redraw
  endfunction

" Show only selected in Visual Mode
nmap <silent> <leader>th :cal ToggleSelected(0)<CR>
vmap <silent> <leader>th :cal ToggleSelected(1)<CR>

""" Switch case from UPPER, lower, Title Case
  function! TwiddleCase(str)
    if a:str ==# toupper(a:str)
      let result = tolower(a:str)
    elseif a:str ==# tolower(a:str)
  "    let result = substitute(a:str,'\C\<\([A\-ZÀ\-Ý]\){1,3}\([A\-ZÀ\-Ý]\+\)\>', '\u\1\L\2', 'g')
      let result = substitute(a:str,'\(\<\w\{4,60}\>\)', '\u\1', 'g')
   else
      let result = toupper(a:str)
    endif
    return result
  endfunction

vnoremap ~ y:call setreg('', TwiddleCase(@"), getregtype(''))<CR>gv""Pgv

" Using tig:
function! s:tig_status()
  cd `driller --scm-root %`
  !tig status
endfunction

map <C-G> :TigStatus<CR><CR>
command! TigStatus call s:tig_status()

" Autoremove white trailing white space:
" autocmd BufWritePre * :%s/\s\+$//e

" Easy-align:
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <Leader>aip)
"nmap <Leader>a <Plug>(EasyAlign)

let g:easy_align_delimiters = {
\':': { 'pattern': '::\|:',
\'left_margin': 1,
\'right_margin': 1,
\'stick_to_left': 0 } }

" TabMan - Toggle:
map <leader>ttm :TMToggle<cr>

" Minimap
map <leader>mm :Minimap<cr>
let g:minimap_highlight='Visual'

" Fix wandering along wrapped lines:
nmap j gj
nmap k gk
nmap <leader>wrap :setlocal wrap!<cr>:setlocal wrap?<cr>

" Colorizer:
let g:colorizer_auto_filetype='css,less,html'


" Vimwiki:
"let g:vimwiki_list = [{'path': '~/vimwiki', 'template_path': '~/vimwiki/templates/',
"          \ 'template_default': 'default', 'syntax': 'markdown', 'ext': '.md',
"          \ 'path_html': '~/vimwiki/site_html/', 'custom_wiki2html': 'vimwiki_markdown',
"          \ 'template_ext': '.tpl'}]

" Orgahelp:
nnoremap <leader>mv ddGp` "move current line to the end of buffer without moving cursor
nnoremap <leader>cp YGp`  "copy current line to the end of buffer without moving cursor
nmap <F7> a<C-R>=strftime("%Y-%m-%d %H:%M")<CR><Esc>
imap <F7> <C-R>=strftime("%Y-%m-%d %H:%M")<CR>
smap <F7> <C-R>=strftime("%Y-%m-%d %H:%M")<CR>

" Switch between the last two files
nnoremap <leader><leader> <c-^>

" Tab wrapper
"function! InsertTabWrapper()
"    let col = col('.') - 1
"    if !col || getline('.')[col - 1] !~ '\k'
"       return "\<tab>"
"    else
"       return "\<c-p>"
"    endif
"endfunction
"inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
"inoremap <S-Tab> <c-n>

" Use one space, not two, after punctuation.
set nojoinspaces

" When editing a file, always jump to the last known cursor position.
" Don't do it for commit messages, when the position is invalid, or when
" inside an event handler (happens when dropping a file on gvim).
augroup vimrcEx
  autocmd!

  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
augroup END

" When the type of shell script is /bin/sh, assume a POSIX-compatible
" shell for syntax highlighting purposes.
let g:is_posix = 1

" Autocomplete with dictionary words when spell check is on
set complete+=kspell

" Always use vertical diffs
set diffopt+=vertical

" Local adaptations:
if filereadable($HOME . "/.vimrc_local")
  source ~/.vimrc_local
endif

" " todo.txt:
" " Use todo#complete as the omni complete function for todo files
" au filetype todo setlocal omnifunc=todo#complete
" " Auto complete projects
" au filetype todo imap <buffer> + +<C-X><C-O>
" " Auto complete contexts
" au filetype todo imap <buffer> @ @<C-X><C-O>

" Calendar
let g:calendar_google_calendar = 1
let g:calendar_google_task = 1

" If silver searcher present:
let g:ackprg = 'rg --vimgrep --no-heading'
let g:ack_autoclose = 1
let g:ackpreview = 1
"cnoreabbrev Ack Ack!
nnoremap <Leader>a :Ack -i<Space>


" FORTRESS:
map <leader>ff :call fortress#format()<cr>
imap <leader>ff :call fortress#format()<cr>

" NVIM:
if has('lua')
"
"  " Neocomplete:
"  let g:acp_enableAtStartup = 0
"  let g:neocomplete#enable_at_startup = 1
"  let g:neocomplete#enable_smart_case = 1
"  let g:neocomplete#sources#syntax#min_keyword_length = 3
"  let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
"  let g:neocomplete#auto_complete_delay = 400
"
"  " Define dictionary.
"  let g:neocomplete#sources#dictionary#dictionaries = {
"      \ 'default' : '',
"      \ 'vimshell' : $HOME.'/.vimshell_hist',
"      \ 'scheme' : $HOME.'/.gosh_completions'
"          \ }
"
"  " Define keyword.
"  if !exists('g:neocomplete#keyword_patterns')
"      let g:neocomplete#keyword_patterns = {}
"  endif
"  let g:neocomplete#keyword_patterns['default'] = '\h\w*'
"
"  " Neocomplete key-mappings.
"  inoremap <expr><C-g>     neocomplete#undo_completion()
"  inoremap <expr><C-l>     neocomplete#complete_common_string()
"
"  " Recommended key-mappings.
"  " <CR>: close popup and save indent.
"  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
"  function! s:my_cr_function()
"    return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
"    " For no inserting <CR> key.
"    "return pumvisible() ? "\<C-y>" : "\<CR>"
"  endfunction
"  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
"  " <C-h>, <BS>: close popup and delete backword char.
"  inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
"  inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
"  " Close popup by <Space>.
"  "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"
"
"  " Enable omni completion.
"  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
"  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
"  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
"  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
"  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"
"  " AutoComplPop like behavior.
"  "let g:neocomplete#enable_auto_select = 1
"
"  " NeoSnippet:
"  imap <C-k>     <Plug>(neosnippet_expand_or_jump)
"  smap <C-k>     <Plug>(neosnippet_expand_or_jump)
"  xmap <C-k>     <Plug>(neosnippet_expand_target)
"
"  " " SuperTab like snippets behavior.
"  " " Note: It must be "imap" and "smap".  It uses <Plug> mappings.
"  " imap <C-k>     <Plug>(neosnippet_expand_or_jump)
"  " "imap <expr><TAB>
"  " " \ pumvisible() ? "\<C-n>" :
"  " " \ neosnippet#expandable_or_jumpable() ?
"  " " \    "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
"  " smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
"  " \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"map <C-k>     <Plug>(neosnippet_expand_target)

" For conceal markers.
if has('conceal')
  set conceallevel=0 concealcursor=niv
endif

" NVIM:
endif "has('lua')

" VimCommander:
noremap <silent> <F12> :cal VimCommanderToggle()<CR>

" TmuxNavigator:
let g:tmux_navigator_save_on_switch = 2
let g:tmux_navigator_no_mappings = 1
nnoremap <silent> <c-h> :TmuxNavigateLeft<cr>
nnoremap <silent> <c-j> :TmuxNavigateDown<cr>
nnoremap <silent> <c-k> :TmuxNavigateUp<cr>
nnoremap <silent> <c-l> :TmuxNavigateRight<cr>

" NarrowRegion:
let g:nrrw_rgn_vert = 1
let g:nrrw_rgn_resize_window = 'relative'
let g:nrrw_rgn_wdth = 50

" Relative line numbers in a Dirvish buffer
"autocmd! FileType dirvish setlocal relativenumber

" Gundo:
nnoremap <leader>u :GundoToggle<CR>

" Taskwarrior:
let g:task_rc_override="rc.defaultwidth=0"
let g:task_rc_override="rc.defaultheight=0"
let g:task_report_name="list"
let g:task_default_prompt = ['description', 'wait', 'due', 'project', 'tag']


" LaTeX:
let g:tex_flavor = 'latex'
au! FocusGained,BufRead,BufEnter,BufNewFile *.tex       set syntax=context wrap
let g:vimtex_latexmk_options = '-verbose -pdf -synctex=1 -interaction=batchmode'
"let g:vimtex_view_general_viewer = 'okular'
"let g:vimtex_view_general_options = '--unique file:@pdf\#src:@line@tex'
"let g:vimtex_view_general_options_latexmk = '--unique'
let g:vimtex_view_general_viewer = 'zathura'
let g:vimtex_view_method = 'zathura'

" VimCompletesMe Integration:
augroup VimCompletesMeTex
    autocmd!
    autocmd FileType tex
        \ let b:vcm_omni_pattern = g:vimtex#re#neocomplete
  augroup END

" LimeLight:
" Color name (:help cterm-colors) or ANSI code
let g:limelight_conceal_ctermfg = 'gray'
let g:limelight_conceal_ctermfg = 240

" Color name (:help gui-colors) or RGB color
let g:limelight_conceal_guifg = 'DarkGray'
let g:limelight_conceal_guifg = '#777777'

" Default: 0.5
let g:limelight_default_coefficient = 0.7

" Number of preceding/following paragraphs to include (default: 0)
"let g:limelight_paragraph_span = 1

" Beginning/end of paragraph
"   When there's no empty line between the paragraphs
"   and each paragraph starts with indentation
"let g:limelight_bop = '^\s'
"let g:limelight_eop = '\ze\n^\s'

" Highlighting priority (default: 10)
"   Set it to -1 not to overrule hlsearch
let g:limelight_priority = -1

" Disable all warnings
"let g:vimtex_quickfix_latexlog = {'default' : 0}
let g:vimtex_quickfix_mode=0

" Sources:
" https://amix.dk/vim/vimrc.html ~Amir Salihefendic
" http://stevelosh.com/blog/2010/09/coming-home-to-vim/ ~Steve Losh
" https://github.com/greg0ire/more-instantly-better-vim ~Dammian Conway
" https://gist.github.com/1470884
" https://gist.github.com/1471147
" https://gist.github.com/2424873
" vim:foldmethod=marker:foldlevel=0
