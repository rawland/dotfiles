" 
" An aspiring engineer invests time in crafting his tools.
"
" Author: Roland Siegbert
"
set nocompatible
filetype plugin indent on       " load file type plugins + indentation
syntax on
set t_Co=256                    " Explicitly tell vim terminal features

" Plugins:
call plug#begin('~/.vim/plugged')

" IDEish:
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }      " Filemanagement
Plug 'Xuyuanp/nerdtree-git-plugin'                          " ... and git
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
Plug 'airblade/vim-gitgutter', { 'on': 'GitGutterEnable' }  " See what changed
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-unimpaired'
Plug 'kien/rainbow_parentheses.vim'
Plug 'scrooloose/syntastic'
Plug 'junegunn/vim-easy-align'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'godlygeek/tabular'
Plug 'skammer/vim-css-color', { 'for': 'css' }
Plug 'ctrlpvim/ctrlp.vim'
Plug 'FelikZ/ctrlp-py-matcher'
Plug 'kien/tabman.vim', { 'on': 'TMToggle' }
Plug 'tpope/vim-surround'
"Plug 'rscircus/vim-fortress'
Plug 'plasticboy/vim-markdown', { 'for' : ['mkd','md','markdown'] }
Plug 'christoomey/vim-tmux-navigator'
Plug 'mtth/scratch.vim'

Plug 'severin-lemaignan/vim-minimap'
Plug 'esneider/YUNOcommit.vim'
"Plug 'gorodinskiy/vim-coloresque'
Plug 'chrisbra/Colorizer'
Plug 'moll/vim-bbye'
Plug 'vim-scripts/EasyMotion'
Plug 'mileszs/ack.vim'                                     " Ack
"NeoVim
Plug 'Shougo/neocomplete.vim'                              " note: needs if_lua
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
Plug 'jeetsukumaran/vim-buffergator'
Plug 'sjl/gundo.vim'                                       " GundoToggle
Plug 'tpope/vim-obsession'                                 " Obession

" File Manager:
Plug 'lpenz/vimcommander'

" Automatic indentation settings:
Plug 'tpope/vim-sleuth'

" Writing:
Plug 'reedes/vim-wordy'
Plug 'junegunn/limelight.vim'
Plug 'lervag/vimtex', {'for': 'tex'}
"install vim-lexical when you need to, one day...

" orga:
Plug 'vim-scripts/todo-txt.vim'
Plug 'vimoutliner/vimoutliner', {'for': 'otl'}
Plug 'rscircus/taskpaper.vim', {'for': 'taskpaper'}
Plug 'vim-voom/VOoM'
Plug 'itchyny/calendar.vim'
Plug 'tpope/vim-speeddating'
Plug 'chrisbra/NrrwRgn'
" Plug 'Rykka/riv.vim' "Doubled loading time

" Color schemes:
Plug 'larssmit/vim-getafe'
Plug 'morhetz/gruvbox'
Plug 'brendonrapp/smyck-vim'
Plug 'reedes/vim-colors-pencil'
Plug 'nanotech/jellybeans.vim'
Plug 'Lokaltog/vim-distinguished'
Plug 'rscircus/vim-lucius'
Plug 'rscircus/summerfruit256.vim'
Plug 'rscircus/vim-tomorrow-theme'
Plug 'junegunn/seoul256.vim'
Plug 'NLKNguyen/papercolor-theme'
Plug 'sjl/badwolf'
Plug 'gosukiwi/vim-atom-dark'
Plug 'lloeki/vim-one-colorschemes'
Plug 'w0ng/vim-hybrid'
Plug 'marcopaganini/termschool-vim-theme'

" Distraction free writing:
Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }
Plug 'reedes/vim-pencil'

" Dev
Plug 'ryanoasis/vim-devicons'

call plug#end()

let mapleader = ","
let maplocalleader = "\<Space>"

"" General vim options
set shell=/bin/bash
set encoding=utf-8
set fileformats=unix,mac,dos " in this order supported file types
set t_ut=                    " This took me quite a while
set showcmd                  " display incomplete commands
set scrolloff=3              " min lines above or below cursor
set visualbell               " I hate the acoustic bell
if has('persistent_undo')
    set undofile             " creates a <FILENAME>.un~ for eternal editing
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif
set nowb                     " use git/svn/hg/eg...
set noswapfile
set nobackup
" set nofoldenable           " Folding
" set foldmarker=#--,--#
" set foldmethod=marker
" set foldlevel=0
set clipboard=unnamed        " yank and paste with the system clipboard
set splitright               " split windows always vertically
au FocusLost * :wall         " Save on lost focus
set lazyredraw               " performance (wait till macro finishes)

if version>=703
    set relativenumber       " show line numbers from current line to calc distances
nnoremap <leader>rn :set relativenumber!<cr>
"let &colorcolumn=join(range(81,999),",") " color all columns >=81
else
    set number
    set numberwidth=5
endif

"" Control
set autoread

" GUI
set guioptions-=T            " don't show toolbar
set guioptions-=m            " don't show menubar
set guioptions-=l            " remove scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=L
set linespace=0              " no extra space between lines (!)
set mat=2                    " Blinks 10ths of seconds"
set title                    " Set terminal title

" Set cursorline in current window and normal mode
augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

set ttimeout                  " Keys but not mappings (sanity!)
set ttimeoutlen=10            " Speed/Responsiveness

"" wildmenu - Ignore files you never want to edit (hopefully)
"if has("wildmenu")
set wildmenu                   " autocompletion
set wildmode=list:longest,list:full       " show all
set wildignore+=*.a,*.o
set wildignore+=*.mod "Fortran
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
set wildignore+=.DS_Store
set wildignore+=*~,*.swp,*.tmp
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*   " for Linux/MacOSX
"endif

set magic                      " regex

" Handle lines:
set textwidth=80
"set colorcolumn=+1
set formatoptions=qrn1
set lbr
set formatprg=par\ -q

" Enable basic mouse behavior such as resizing buffers.
set mouse=a
if exists('$TMUX')              " Support resizing in tmux
  set ttymouse=xterm2
endif

" Highlight only the lines that go past 80 characters
" augroup vimrc_autocmds
"     autocmd BufEnter * highlight OverLength ctermbg=255 guibg=#592929
"     autocmd BufEnter * match OverLength /\%79v.*/
" augroup END

"" Whitespace
set nowrap                       "No wrapping of lines per default
"set tabstop=4                   "Indent 4 spaces with <TAB>
"set softtabstop=4
"set shiftwidth=4                "Indent 4 spaces with >>
"set smarttab
"set expandtab
"set shiftround                  " At 3 spaces >> goes to 4
set autoindent                   " Keep indent, when indented
set cindent                      " Like smartindent, but more clever
set copyindent
set smartindent                  " Helps indenting after/before specific keywords
set backspace=indent,eol,start   " backspace through everything in insert mode
set listchars=tab:»\ ,eol:¬,extends:❯,precedes:❮,trail:▫,nbsp:▫
set fillchars=diff:⣿,vert:│
"set showbreak=↪
"set list
nnoremap <leader>tl :set list!<cr>
nnoremap <F2> :set invpaste paste?<cr>
set pastetoggle=<F2>
set showmode

"" Look and feel
syntax enable
let g:solarized_contrast="high"    "default value is normal
let g:solarized_visibilty="high"
let g:solarized_termtrans=1
let g:solarized_termcolors=256

let g:seoul256_background = 233
let g:seoul256_light_background = 256

let g:pencil_terminal_italics = 0
let g:pencil_higher_contrast_ui = 1   " 0=low (def), 1=high

"let g:PaperColor_Light_Override = { 'background' : '#abcdef', 'cursorline' : '#dfdfff', 'matchparen' : '#d6d6d6' , 'comment' : '#8e908c' }
let g:PaperColor_Light_Override = { 'background' : '#fdfdfd'} " Brighten up


"" Environment:
set background=dark

"" Bright Environment:
"color summerfruit256
"color seoul256-light
color PaperColor
"color one-light
"color pencil

"" Dark Environment:
"color jellybeans
"color gruvbox
"color badwolf

" Do not underline CursorLine:
set cursorline                  " highlight current line
:hi CursorLine cterm=NONE
:nnoremap <leader>H :set cursorline!<CR>

" Change background with F6
function! ToggleBackgroundColor()
  if (&background == 'light')
    set background=dark
    echo "background -> dark"
  else
    set background=light
    echo "background -> light"
  endif
endfunction
map <F6>  :call ToggleBackgroundColor()<CR>

" GUI:
if has("gui_running")
    "colorscheme seoul256-light
    color PaperColor
    set relativenumber          " show line numbers from current line to calc distances
    if has("gui_gtk2")
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types\ 11
    else
      set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Plus\ Nerd\ File\ Types:h11
    endif
endif

" Searching:
noremap / /\v
vnoremap / /\v
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter`
set showmatch                   " show matches
set gdefault                    " replacing globally is default
set incsearch                   " incremental searching
set nohlsearch
nmap <leader>h :set nohlsearch!<cr>

" Fix many hits:
    function! HLNext (blinktime)
        let [bufnum, lnum, col, off] = getpos('.')
        let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
        let target_pat = '\c\%#'.@/
        let ring = matchadd('ErrorMsg', target_pat, 101)
        redraw
        exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
        call matchdelete(ring)
        redraw
    endfunction
" This rewires n and N to do the highlighing...
nnoremap <silent> n   n:call HLNext(0.4)<cr>
nnoremap <silent> N   N:call HLNext(0.4)<cr>

" Toggle spell checking on and off with `,s`
let mapleader = ","
nmap <silent> <leader>s :set spell!<CR>

" Set region to British English
set spelllang=en_gb

"" Copy and paste
vmap <C-c> "+yi
vmap <C-x> "+c
vmap <C-v> c<ESC>"+p
imap <C-v> <C-r><C-o>+

"" Window movement
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

"" Buffers
map <leader>bd :Bclose<cr>
map <leader>cd :cd %:p:h<cr>
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <right> :bn<cr>
map <left> :bp<cr>

"" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

" Reasonable Buffer closure
command! Bclose call <SID>BufcloseCloseIt()
  function! <SID>BufcloseCloseIt()
     let l:currentBufNum = bufnr("%")
     let l:alternateBufNum = bufnr("#")

     if buflisted(l:alternateBufNum)
       buffer #
     else
       bnext
     endif

     if bufnr("%") == l:currentBufNum
       new
     endif

     if buflisted(l:currentBufNum)
       execute("bdelete! ".l:currentBufNum)
     endif
  endfunction

" Edit this file:
nnoremap <leader>rc <C-w><C-v><C-l>:e $MYVIMRC<cr>

" Exit input mode:
inoremap jk <Esc>
inoremap jj <ESC>

" Bash like keys for the command line
cnoremap <C-A> <Home>
"- collides with Riv (ReSt)
cnoremap <C-E> <End> 
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Tagbar plugin:
let g:tagbar_usearrows = 1
let g:tagbar_indent = 1              " spaces
let g:tagbar_sort = 0                " appearance = 0, name = 1
let g:tagbar_autopreview = 0
let g:tagbar_autofocus = 1
let g:tagbar_autoclose = 1
let g:tagbar_width = 40
let g:tagbar_compact = 1
nnoremap <leader>l :TagbarToggle<CR>

" Scratch:
let g:scratch_filetype = 'markdown'
let g:scratch_persistence_file = 'scratch.vim'

" Redfine markdown tags
if executable('marktag')
    let g:tagbar_type_markdown = {
        \ 'ctagstype' : 'markdown',
        \ 'ctagsbin' : 'marktag',
        \ 'kinds' : [
            \ 'h:header'
        \ ],
        \ 'sro' : '.',
        \ 'kind2scope' : {
            \ 'h' : 'header'
        \  },
        \ 'scope2kind' : {
            \ 'header' : 'h'
        \ }
    \ }
" Default tagbar behavior, if now marktag present
else
    let g:tagbar_type_markdown = {
      \ 'ctagstype' : 'markdown',
      \ 'kinds' : [
        \ 'h:Heading_L1',
        \ 'i:Heading_L2',
        \ 'k:Heading_L3'
      \ ]
    \ }
end

" Markdown:
let g:vim_markdown_folding_disabled = 1
let g:vim_markdown_math = 1
let g:vim_markdown_toc_autofit = 1
let g:vim_markdown_frontmatter = 1
set conceallevel=2

" Syntastic Plugin:
let g:syntastic_fortran_flags = '-ffree-form'
let g:syntastic_fortran_fortran_exec = 'gfortran'

"" Git Gutter:
"let g:gitgutter_enabled = 1
map <leader>g :GitGutterToggle<cr>
map <leader>g :GitGutterEnable<cr>
map <leader>gg :GitGutterLineHighlightsToggle<cr>

" TaskPaper:
:let g:notes_directories = ['~/usr/cld/orga/notes']
:let g:notes_suffix = '.note'

"" TextBubbling:
" single line
nmap <C-Up> ddkP
nmap <C-Down> ddp
" multi line
vmap <C-Up> xkP`[V`]
vmap <C-Down> xp`[V`]

"" CtrlP:
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_match_window_bottom = 0
let g:ctrlp_match_window_reversed = 0
let g:ctrlp_custom_ignore = '\v\~$|\.(o|swp|pyc|wav|mp3|ogg|blend)$|(^|[/\\])\.(hg|git|bzr)($|[/\\])|__init__\.py'
let g:ctrlp_working_path_mode = 0
let g:ctrlp_dotfiles = 0
let g:ctrlp_switch_buffer = 0
let g:ctrlp_clear_cache_on_exit = 0

let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
" let g:ctrlp_custom_ignore = {
"   \ 'dir':  '\.git$\|\.hg$\|\.svn$',
"   \ 'file': '\.exe$\|\.so$\|\.dll$',
"   \ 'link': 'some_bad_symbolic_links',
"   \ }
if has("python")
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif
let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
      \ --ignore .git
      \ --ignore .svn
      \ --ignore .hg
      \ --ignore .DS_Store
      \ --ignore "**/*.pyc"
      \ -g ""'

:nmap <leader>tf :set expandtab tabstop=4 shiftwidth=4 softtabstop=4<CR>
:nmap <leader>tc :set expandtab tabstop=8 shiftwidth=8 softtabstop=4<CR>
:nmap <leader>tM :set noexpandtab tabstop=8 softtabstop=4 shiftwidth=4<CR>
:nmap <leader>tm :set expandtab tabstop=2 shiftwidth=2 softtabstop=2<CR>


"" Airline:
set laststatus=2
let g:airline#extensions#syntastic#enabled = 1
let g:airline_extensions = ['branch']
let g:airline_theme='papercolor'

""" Buffergator:
let g:buffergator_sort_regime = 'basename'
let g:buffergator_autoupdate = 1
let g:buffergator_show_full_directory_path = 0
let g:buffergator_vsplit_size = 35

" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'

" reset airline symbols
"  if !exists('g:airline_symbols')
"    let g:airline_symbols = {}
"  endif
"
"" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_linecolumn_prefix = '␊ '
"let g:airline_linecolumn_prefix = '␤ '
"let g:airline_linecolumn_prefix = '¶ '
"let g:airline_fugitive_prefix = '⎇ '
"let g:airline_paste_symbol = 'ρ'
"let g:airline_paste_symbol = 'Þ'
"let g:airline_paste_symbol = '∥'

let g:airline_powerline_fonts = 1

"" NERDTree
map <leader>nn :NERDTreeToggle<cr>
map <leader>nb :NERDTreeFromBookmark<cr>
map <leader>nf :NERDTreeFind<cr>
let NERDTreeIgnore=['\~$', '\.pyc']
let NERDTreeRespectWildIgnore=1
let NERDTreeWinSize = 30

"" Rainbow parentheses
map <leader>r :RainbowParenthesesToggle<cr>

" Load per default:
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces

"" autoreload vimrc - you might want to change that line
autocmd! bufwritepost vimrc source ~/dotfiles/vim/vimrc

"" XNS
au BufNewFile,BufRead xns.in set filetype=xns
au BufNewFile,BufRead *.less set filetype=less

"" Fortran
let fortran_dialect = 'f90'
let fortran_fixed_source = 0
let fortran_free_source = 1
hi link fortranTab NONE
au BufRead,BufNewFile *.F set noexpandtab
" au BufRead,BufNewFile *.F set softtabstop=0
"au BufRead,BufNewFile *.F set shiftwidth=0
" https://gist.github.com/1470884
" https://gist.github.com/1471147
" https://gist.github.com/2424873
"" last/newest one is used here

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
" Source: https://github.com/scrooloose/nerdtree/issues/21
  function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
      if bufwinnr(t:NERDTreeBufName) != -1
	if winnr("$") == 1
	  q
	endif
      endif
    endif
  endfunction

" Close NERDTree if it is the last buffer open
autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()

"" Goyo:
nnoremap <leader>G :Goyo<cr>

" Remove trailing whitespace
" http://vim.wikia.com/wiki/Remove_unwanted_spaces
  function! StripTrailingWhitespace()
      if !&binary && &filetype != 'diff'
	  normal mz
	  normal Hmy
	  %s/\s\+$//e
	  normal 'yz<CR>
	  normal `z
	  retab
      endif
  endfunction
nmap <leader>tw :call StripTrailingWhitespace()<CR>

" Function to hide all the text except for the text selected in visual mode.
" This is great for highlighting parts of the code. Just call the function
" again to deselect everything.
  function! ToggleSelected(visual) range
      highlight HideSelected ctermfg=bg ctermbg=bg
			   \ guifg=bg guibg=bg gui=none term=none cterm=none

      if exists("g:toggle_selected_hide")
	  call matchdelete(g:toggle_selected_hide)

	  unlet g:toggle_selected_hide
	  redraw

	  if !a:visual
	      return
	  endif
      endif

      let [lnum1, col1] = getpos("'<")[1:2]
      let [lnum2, col2] = getpos("'>")[1:2]

      let pattern = '\%^\|\%<'.lnum1.'l\|\%<'.col1.'v\|\%>'.lnum2.'l\|\%>'.col2.'v'
      let g:toggle_selected_hide = matchadd('HideSelected', pattern, 1000)

      redraw
  endfunction

" Show only selected in Visual Mode
nmap <silent> <leader>th :cal ToggleSelected(0)<CR>
vmap <silent> <leader>th :cal ToggleSelected(1)<CR>

""" Switch case from UPPER, lower, Title Case
  function! TwiddleCase(str)
    if a:str ==# toupper(a:str)
      let result = tolower(a:str)
    elseif a:str ==# tolower(a:str)
  "    let result = substitute(a:str,'\C\<\([A\-ZÀ\-Ý]\){1,3}\([A\-ZÀ\-Ý]\+\)\>', '\u\1\L\2', 'g')
      let result = substitute(a:str,'\(\<\w\{4,60}\>\)', '\u\1', 'g')
   else
      let result = toupper(a:str)
    endif
    return result
  endfunction

vnoremap ~ y:call setreg('', TwiddleCase(@"), getregtype(''))<CR>gv""Pgv

" Autoremove white trailing white space:
" autocmd BufWritePre * :%s/\s\+$//e

" Easy-align:
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <Leader>aip)
nmap <Leader>a <Plug>(EasyAlign)

let g:easy_align_delimiters = {
\':': { 'pattern': '::\|:',
\'left_margin': 1,
\'right_margin': 1,
\'stick_to_left': 0 } }

" TabMan - Toggle:
map <leader>ttm :TMToggle<cr>

" Minimap
map <leader>m :Minimap<cr>
let g:minimap_highlight='Visual'

" Fix wandering along wrapped lines:
nmap j gj
nmap k gk
nmap <leader>wrap :setlocal wrap!<cr>:setlocal wrap?<cr>

" Colorizer:
let g:colorizer_auto_filetype='css,less,html'

" Orgahelp:
nnoremap <leader>mv ddGp` "move current line to the end of buffer without moving cursor
nnoremap <leader>cp YGp`  "copy current line to the end of buffer without moving cursor
nmap <F5> a<C-R>=strftime("%Y-%m-%d %a %H:%M")<CR><Esc>
imap <F5> <C-R>=strftime("%Y-%m-%d %a %H:%M")<CR>

" Switch between the last two files
nnoremap <leader><leader> <c-^>

" Tab wrapper
"  function! InsertTabWrapper()
"      let col = col('.') - 1
"      if !col || getline('.')[col - 1] !~ '\k'
"	  return "\<tab>"
"      else
"	  return "\<c-p>"
"      endif
"  endfunction
"inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
"inoremap <S-Tab> <c-n>

" Use one space, not two, after punctuation.
set nojoinspaces

" When editing a file, always jump to the last known cursor position.
" Don't do it for commit messages, when the position is invalid, or when
" inside an event handler (happens when dropping a file on gvim).
augroup vimrcEx
  autocmd!

  " When editing a file, always jump to the last known cursor position.
  " Don't do it for commit messages, when the position is invalid, or when
  " inside an event handler (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif
augroup END

augroup WrapLineInMarkdownFile
    autocmd!
    autocmd FileType markdown setlocal wrap
augroup END

" When the type of shell script is /bin/sh, assume a POSIX-compatible
" shell for syntax highlighting purposes.
let g:is_posix = 1

" Autocomplete with dictionary words when spell check is on
set complete+=kspell

" Always use vertical diffs
set diffopt+=vertical

" Local adaptations:
if filereadable($HOME . "/.vimrc_local")
  source ~/.vimrc_local
endif

" " todo.txt:
" " Use todo#complete as the omni complete function for todo files
" au filetype todo setlocal omnifunc=todo#complete
" " Auto complete projects
" au filetype todo imap <buffer> + +<C-X><C-O>
" " Auto complete contexts
" au filetype todo imap <buffer> @ @<C-X><C-O>

" Calendar
let g:calendar_google_calendar = 1
let g:calendar_google_task = 1

" If silver searcher present:
let g:ackprg = 'ag --nogroup --nocolor --column'
let g:ack_autoclose = 1
let g:ackpreview = 1

" FORTRESS:
map <leader>ff :call fortress#format()<cr>
imap <leader>ff :call fortress#format()<cr>

" NeoComplete:
"
" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? "\<C-y>" : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
" Close popup by <Space>.
"inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

" AutoComplPop like behavior.
"let g:neocomplete#enable_auto_select = 1

" NeoSnippet:
imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
" For conceal markers.
if has('conceal')
  set conceallevel=2 concealcursor=niv
endif

" VimCommander:
noremap <silent> <F12> :cal VimCommanderToggle()<CR>

" Sources:
" https://amix.dk/vim/vimrc.html ~Amir Salihefendic
" http://stevelosh.com/blog/2010/09/coming-home-to-vim/ ~Steve Losh
" https://github.com/greg0ire/more-instantly-better-vim ~Dammian Conway

