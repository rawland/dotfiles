filetype plugin indent on       " load file type plugins + indentation

"vim-plug will replace pathogen due to lazy loading
call plug#begin('~/.vim/plugged')

" IDE-ish:
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'majutsushi/tagbar'
Plug 'airblade/vim-gitgutter', { 'on': 'GitGutterToggle' }
Plug 'tpope/vim-fugitive'
Plug 'kien/rainbow_parentheses.vim', { 'on': 'RainbowParenthesesToggle' }
Plug 'scrooloose/syntastic'
Plug 'junegunn/vim-easy-align'
Plug 'bling/vim-airline'
Plug 'skammer/vim-css-color', { 'for': 'css' }
Plug 'kien/ctrlp.vim'
Plug 'kien/tabman.vim', { 'on': 'TMToggle' }
Plug 'tpope/vim-surround'
Plug 'plasticboy/vim-markdown', { 'for' : 'mkd' }

" Automatic indentation settings:
Plug 'tpope/vim-sleuth'

" Color schemes:
Plug 'larssmit/vim-getafe'
Plug 'morhetz/gruvbox'
Plug 'twerth/ir_black'
Plug 'brendonrapp/smyck-vim'

" Distraction free writing:
Plug 'junegunn/goyo.vim', { 'on': 'Goyo' }

Plug 'vimwiki/vimwiki'

call plug#end()

let mapleader = ","

"" General vim options
set encoding=utf-8
set fileformats=unix,mac,dos    " in this order supported file types
set nocompatible
set showcmd                     " display incomplete commands
set scrolloff=3                 " min lines above or below cursor
set visualbell                  " I hate the acoustic bell
set cursorline                  " highlight current line
if has('persistent_undo')
    set undofile                    " creates a <FILENAME>.un~ for eternal editing
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif
set nowb                        " use git/svn/hg/eg...
set noswapfile
set nobackup
set nofoldenable
set foldmethod=indent
if version>=703
    set relativenumber              " show line numbers from current line to calc distances
else
    set number
endif

"" Control
set autoread

" GUI
set guioptions-=T               " don't show toolbar
set guioptions-=m               " don't show menubar
set guioptions-=l               " remove scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=L
set linespace=0                                 " no extra space between lines (!)
set mat=2                       " Blinks 10ths of seconds"
au FocusLost * :wall            " Save on lost focus
set title                       " Set terminal title

" Set cursorline in current window and normal mode
augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

set ttimeout                    " Keys but not mappings (sanity!)
set ttimeoutlen=10              " Speed/Responsiveness

"" wildmenu - Ignore files you never want to edit (hopefully)
if has("wildmenu")
  set wildmenu                    " autocompletion
  set wildmode=list:longest       " show all
  set wildignore+=*.a,*.o
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
  set wildignore+=.DS_Store
  set wildignore+=*~,*.swp,*.tmp
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*   " for Linux/MacOSX
  "set wildignore+=.git\*,.hg\*,.svn\*         " for Windows
endif

set magic                         " regex

"" Hande lines
set formatoptions=qrn1

" Highlight only the lines that go past 80 characters
highlight ColorColumn ctermbg=green guibg=green
call matchadd('ColorColumn', '\%82v', 100)

set lbr
set nowrap

"" Whitespace
"set tabstop=4                   "Indent 4 spaces with <TAB>
"set softtabstop=4
"set shiftwidth=4                 "Indent 4 spaces with >>
"set smarttab
"set expandtab
"set cindent                     " Like smartindent, but more clever
"set shiftround                   " At 3 spaces >> goes to 4
set smartindent                  " Helps indenting after/before specific keywords
"set autoindent                   " Keep indent, when indented
set backspace=indent,eol,start   " backspace through everything in insert mode
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮
set fillchars=diff:⣿,vert:│
set showbreak=↪
"set list
nnoremap <leader>tt :set list!<cr>
nnoremap <F2> :set invpaste paste?<cr>
set pastetoggle=<F2>
set showmode

"" Look and feel
syntax enable
let g:solarized_contrast="high"    "default value is normal
let g:solarized_visibilty="high"
let g:solarized_termtrans=1
let g:solarized_termcolors=256
set background=dark
set splitright                  " split windows always vertically
set t_Co=256                    " Explicitly tell vim terminal features

let g:seoul256_background = 233
let g:seoul256_light_background = 256
colorscheme smyck

function! ToggleBackgroundColor()
  if (&background == 'light')
    set background=dark
    echo "background -> dark"
  else
    set background=light
    echo "background -> light"
  endif
endfunction

if has("gui_running")
    "set guifont=Source\ Code\ Pro\ for\ Powerline:h11
    colorscheme getafe
    set guifont=Ubuntu\ Mono\ derivative\ Powerline:h13
    "set guifont=Monaco:h11
    "set guifont=Inconsolata-dz\ for\ Powerline:h11
endif

"" Searching
noremap / /\v
vnoremap / /\v
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter`

set gdefault                    " replacing globally is default
set nohlsearch                  " do not highlight search
set showmatch                   " show matches
set incsearch                   " incremental searching

"" ESC:
inoremap jj <ESC>

" Toggle spell checking on and off with `,s`
let mapleader = ","
nmap <silent> <leader>s :set spell!<CR>

" Set region to British English
set spelllang=en_gb

"" Window movement
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

"" Buffers
map <leader>bd :Bclose<cr>
map <leader>cd :cd %:p:h<cr>
nmap <leader>wr :w!<cr>
map <leader>bn :bn<cr>
map <leader>bp :bp<cr>
map <right> :bn<cr>
map <left> :bp<cr>

"" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove

command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction

" Bash like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

"" Change keyboard shortcuts
nnoremap <leader>e <C-w><C-v><C-l>:e $MYVIMRC<cr>
map <F5>  :call ToggleBackgroundColor()<CR>
inoremap jk <Esc>                                   " Hardcore vim

"" Tagbar plugin
let g:taskbar_usearrows = 1
nnoremap <leader>l :TagbarToggle<CR>

"" Synatstic plugin:
let g:syntastic_fortran_flags = '-ffree-form'

"" Git Gutter:
map <leader>g :GitGutterToggle<cr>
map <leader>gg :GitGutterLineHighlightsToggle<cr>

"" Goyo:
nnoremap <leader>G :Goyo<cr>

function! OrgustomColors()
    hi! Org_Drawer guifg=#586e75 ctermfg=magenta
    hi! Org_Drawer_Folded guifg=#586e75 ctermfg=magenta gui=bold cterm=bold
    hi! Org_Property_Value guifg=#657b83 ctermfg=magenta
    hi! Org_Block guifg=#586375 ctermfg=magenta
    hi! Org_Date guifg=#657b83 ctermfg=magenta gui=underline cterm=underline
    let g:org_todo_custom_highlights =
            \     { 'NEXT': { 'guifg':'#888888', 'guibg':'#222222',
            \              'ctermfg':'gray', 'ctermbg':'darkgray'},
            \      'WAITING': { 'guifg':'#aa3388',
            \                 'ctermfg':'red' } }

endfunction

"" YankRing
nnoremap <silent> <F12> :YRShow<cr>

"" CtrlP
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'

let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
" let g:ctrlp_custom_ignore = {
"   \ 'dir':  '\.git$\|\.hg$\|\.svn$',
"   \ 'file': '\.exe$\|\.so$\|\.dll$',
"   \ 'link': 'some_bad_symbolic_links',
"   \ }

"" SuperTab
"This doesn't work for console version?:
"let g:SuperTabMappingForward = '<c-space>'
"let g:SuperTabMappingBackward = '<s-c-space>'
let g:SuperTabMappingForward = '<nul>'
let g:SuperTabMappingBackward = '<s-nul>'


""" Airline
set laststatus=2
let g:airline_enable_syntastic=1
let g:airline_enable_branch=1
let g:airline_theme='powerlineish'

" Enable the list of buffers
let g:airline#extensions#tabline#enabled = 1

" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'

" reset airline symbols
"  if !exists('g:airline_symbols')
"    let g:airline_symbols = {}
"  endif
"
"" unicode symbols
"let g:airline_left_sep = '»'
"let g:airline_left_sep = '▶'
"let g:airline_right_sep = '«'
"let g:airline_right_sep = '◀'
"let g:airline_linecolumn_prefix = '␊ '
"let g:airline_linecolumn_prefix = '␤ '
"let g:airline_linecolumn_prefix = '¶ '
"let g:airline_fugitive_prefix = '⎇ '
"let g:airline_paste_symbol = 'ρ'
"let g:airline_paste_symbol = 'Þ'
"let g:airline_paste_symbol = '∥'

let g:airline_powerline_fonts = 1

""" vimwiki:
"let g:vimwiki_list = [{'path': '~/share/vimwiki/', 'syntax': 'markdown', 'ext': '.md'}]

"" NERDTree
map <leader>nn :NERDTreeToggle<cr>
map <leader>nb :NERDTreeFromBookmark
map <leader>nf :NERDTreeFind<cr>

"" Rainbow parentheses
map <leader>r :RainbowParenthesesToggle<cr>

"" autoreload vimrc - you might want to change that line
autocmd! bufwritepost vimrc source ~/dotfiles/vim/vimrc

"" XNS
au BufNewFile,BufRead xns.in set filetype=xns

"" Markdown
au BufNewFile,BufRead *.md set ft=mkd

"" Fortran
let fortran_dialect = 'f90'
let fortran_fixed_source = 0
let fortran_free_source = 1
hi link fortranTab NONE
au BufRead,BufNewFile *.F set noexpandtab
" au BufRead,BufNewFile *.F set softtabstop=0
"au BufRead,BufNewFile *.F set shiftwidth=0
" https://gist.github.com/1470884
" https://gist.github.com/1471147
" https://gist.github.com/2424873
"" last/newest one is used here

"" Everything else:
":autocmd BufReadPost * :DetectIndent
autocmd BufNewFile,BufRead *.ino setlocal ft=arduino

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
" Source: https://github.com/scrooloose/nerdtree/issues/21
function! s:CloseIfOnlyNerdTreeLeft()
  if exists("t:NERDTreeBufName")
    if bufwinnr(t:NERDTreeBufName) != -1
      if winnr("$") == 1
        q
      endif
    endif
  endif
endfunction

" Close NERDTree if it is the last buffer open
autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()

"" Map Goyo toggle to <Leader> + spacebar
nnoremap <Leader><Space> :Goyo<CR>

" Remove trailing whitespace
" http://vim.wikia.com/wiki/Remove_unwanted_spaces
function! StripTrailingWhitespace()
    if !&binary && &filetype != 'diff'
        normal mz
        normal Hmy
        %s/\s\+$//e
        normal 'yz<CR>
        normal `z
        retab
    endif
endfunction

nmap <leader>tw :call StripTrailingWhitespace()<CR>

" Function to hide all the text except for the text selected in visual mode.
" This is great for highlighting parts of the code. Just call the function
" again to deselect everything.
function! ToggleSelected(visual) range
    highlight HideSelected ctermfg=bg ctermbg=bg
                         \ guifg=bg guibg=bg gui=none term=none cterm=none

    if exists("g:toggle_selected_hide")
        call matchdelete(g:toggle_selected_hide)

        unlet g:toggle_selected_hide
        redraw

        if !a:visual
            return
        endif
    endif

    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]

    let pattern = '\%^\|\%<'.lnum1.'l\|\%<'.col1.'v\|\%>'.lnum2.'l\|\%>'.col2.'v'
    let g:toggle_selected_hide = matchadd('HideSelected', pattern, 1000)

    redraw
endfunction

" Show only selected in Visual Mode
nmap <silent> <leader>th :cal ToggleSelected(0)<CR>
vmap <silent> <leader>th :cal ToggleSelected(1)<CR>

""" Switch case from UPPER, lower, Title Case
function! TwiddleCase(str)
  if a:str ==# toupper(a:str)
    let result = tolower(a:str)
  elseif a:str ==# tolower(a:str)
"    let result = substitute(a:str,'\C\<\([A\-ZÀ\-Ý]\){1,3}\([A\-ZÀ\-Ý]\+\)\>', '\u\1\L\2', 'g')
    let result = substitute(a:str,'\(\<\w\{4,60}\>\)', '\u\1', 'g')
 else
    let result = toupper(a:str)
  endif
  return result
endfunction

vnoremap ~ y:call setreg('', TwiddleCase(@"), getregtype(''))<CR>gv""Pgv

" Autoremove white trailing white space:
autocmd BufWritePre * :%s/\s\+$//e

"" Remap vim's autocompletion to Tab-Key:
"Use TAB to complete when typing words, else inserts TABs as usual.
"Uses dictionary and source files to find matching words to complete.

"See help completion for source,
"Note: usual completion is on <C-n> but more trouble to press all the time.
"Never type the same word twice and maybe learn a new spellings!
"Use the Linux dictionary when spelling is in doubt.
"Window users can copy the file to their machine.
function! Tab_Or_Complete()
  if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
    return "\<C-N>"
  else
    return "\<Tab>"
  endif
endfunction
:inoremap <Tab> <C-R>=Tab_Or_Complete()<CR>
:set dictionary="/usr/dict/words"

" Easy-align:
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. <Leader>aip)
nmap <Leader>a <Plug>(EasyAlign)

" TabMan - Toggle:
map <leader>ttm :TMToggle<cr>

source ~/.vimrc_local

