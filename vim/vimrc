call pathogen#runtime_append_all_bundles()          " pathogen
call pathogen#helptags()
filetype plugin indent on       " load file type plugins + indentation
let mapleader = ","

"" General vim options
set encoding=utf-8
set fileformats=unix,mac,dos    " in this order supported file types
set nocompatible
set showcmd                     " display incomplete commands
set scrolloff=3                 " min lines above or below cursor
set visualbell                  " I hate the acoustic bell
set cursorline                  " highlight current line
if has('persistent_undo')
    set undofile                    " creates a <FILENAME>.un~ for eternal editing
    set undodir=~/.vim/undodir
    set undolevels=1000
    set undoreload=10000
endif
set nowb                        " use git/svn/hg/eg...
set noswapfile
set nobackup
set nofoldenable
set foldmethod=indent
"set relativenumber              " show line numbers from current line to calc distances

"" Control
set autoread

" GUI
set guioptions-=T               " don't show toolbar
set guioptions-=m               " don't show menubar
set guioptions-=l               " remove scrollbars
set guioptions-=r
set guioptions-=R
set guioptions-=L
set linespace=0 								" no extra space between lines (!)
set mat=2                       " Blinks 10ths of seconds"
au FocusLost * :wall            " Save on lost focus
set title                       " Set terminal title

" Set cursorline in current window and normal mode
augroup cline
    au!
    au WinLeave * set nocursorline
    au WinEnter * set cursorline
    au InsertEnter * set nocursorline
    au InsertLeave * set cursorline
augroup END

set ttimeout                    " Keys but not mappings (sanity!)
set ttimeoutlen=10              " Speed/Responsiveness

"" wildmenu - Ignore files you never want to edit (hopefully)
if has("wildmenu")
  set wildmenu                    " autocompletion
  set wildmode=list:longest       " show all
  set wildignore+=*.a,*.o
  set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png
  set wildignore+=.DS_Store
  set wildignore+=*~,*.swp,*.tmp
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*   " for Linux/MacOSX
  "set wildignore+=.git\*,.hg\*,.svn\*         " for Windows
endif

set magic                         " regex

"" Hande lines
set formatoptions=qrn1

" set colorcolumn=79
" Highlight only the lines that go past 80 characters
highlight ColorColumn ctermbg=green guibg=green
call matchadd('ColorColumn', '\%82v', 100)

set lbr
set nowrap

"" Whitespace
set tabstop=4                   "Indent 4 spaces with <TAB>
"set softtabstop=4
set shiftwidth=4                 "Indent 4 spaces with >>
"et smarttab
set expandtab
"set cindent                     " Like smartindent, but more clever
set shiftround                   " At 3 spaces >> goes to 4
set smartindent                  " Helps indenting after/before specific keywords
set autoindent                   " Keep indent, when indented
set backspace=indent,eol,start   " backspace through everything in insert mode
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮
set fillchars=diff:⣿,vert:│
set showbreak=↪
"set list
nnoremap <leader>t :set list!<cr>
nnoremap <F2> :set invpaste paste?<cr>
set pastetoggle=<F2>
set showmode



"" Look and feel
syntax enable
let g:solarized_contrast="high"    "default value is normal
let g:solarized_visibilty="high"
let g:solarized_termtrans=1
let g:solarized_termcolors=256
set background=light
set splitright                  " split windows always vertically
set t_Co=256                    " Explicitly tell vim terminal features

function ToggleBackgroundColor()
  if (&background == 'light')
    set background=dark
    echo "background -> dark"
  else
    set background=light
    echo "background -> light"
  endif
endfunction

if has("gui_running")
"   set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ Book\ 10
    set guifont=Inconsolata-dzForPowerline\ 10
    colorscheme Tomorrow-Night-Bright
else
" colorscheme jellybeans
    colorscheme Tomorrow-Night-Bright
endif


"" Searching
noremap / /\v
vnoremap / /\v
set ignorecase                  " searches are case insensitive...
set smartcase                   " ... unless they contain at least one capital letter`

set gdefault                    " replacing globally is default
set nohlsearch                  " do not highlight search
set showmatch                   " show matches
set incsearch                   " incremental searching

"" ESC:
inoremap jj <ESC>

" Toggle spell checking on and off with `,s`
let mapleader = ","
nmap <silent> <leader>s :set spell!<CR>

" Set region to British English
set spelllang=en_gb

"" Window movement
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

"" Buffers
map <leader>bd :Bclose<cr>
map <leader>cd :cd %:p:h<cr>
nmap <leader>w :w!<cr>
map <right> :bn<cr>
map <left> :bp<cr>

"" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove


command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction

" Bash like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

"" Change keyboard shortcuts
nnoremap <leader>e <C-w><C-v><C-l>:e $MYVIMRC<cr>
map <F5>  :call ToggleBackgroundColor()<CR>
inoremap jk <Esc>                                   " Hardcore vim

"" Numbers plugin
nnoremap <F3> :NumbersToggle<CR>
" set rnu
" au InsertEnter * :set nu
" au InsertLeave * :set rnu
" au FocusLost * :set nu
" au FocusGained * :set rnu

"" Tagbar plugin
let g:taskbar_usearrows = 1
nnoremap <leader>l :TagbarToggle<CR>

"" Synatstic plugin:
let g:syntastic_fortran_flags = '-ffree-form'

"" Extending tabar to support markdown (additionally to the ~/.ctags-file!)
let g:tagbar_type_mkd = {
	\ 'ctagstype' : 'markdown',
	\ 'kinds' : [
		\ 'h:Heading_L1',
		\ 'i:Heading_L2',
		\ 'k:Heading_L3'
	\ ]
\ }

"" vimorganizer:
au! BufRead,BufWrite,BufWritePost,BufNewFile *.org
au BufEnter *.org            call org#SetOrgFileType()
let g:ft_ignore_pat = '\.org'
let g:org_command_for_emacsclient = 'emacsclient'
let g:org_capture_file = '~/org/refile.org'
let g:org_agenda_files = split(glob("~/org/*.org"),"\n")
let g:org_agenda_include_clocktable = 1
let g:org_todo_setup = 'TODO NEXT WAITING | CANCELLED DONE'
let g:org_tags_alist='{@home(h) @work(w)} {easy(e) hard(d)} {computer(c) phone(p)}'
command! OrgCapture :call org#CaptureBuffer()
command! OrgCaptureFile :call org#OpenCaptureFile()
nnoremap <leader>c :OrgCapture<cr>

"" Git Gutter:
map <leader>g :ToggleGitGutter<cr>
map <leader>gg :ToggleGitGutterLineHighlights<cr>

function! OrgustomColors()
    hi! Org_Drawer guifg=#586e75 ctermfg=magenta
    hi! Org_Drawer_Folded guifg=#586e75 ctermfg=magenta gui=bold cterm=bold
    hi! Org_Property_Value guifg=#657b83 ctermfg=magenta
    hi! Org_Block guifg=#586375 ctermfg=magenta
    hi! Org_Date guifg=#657b83 ctermfg=magenta gui=underline cterm=underline
    let g:org_todo_custom_highlights =
            \     { 'NEXT': { 'guifg':'#888888', 'guibg':'#222222',
            \              'ctermfg':'gray', 'ctermbg':'darkgray'},
            \      'WAITING': { 'guifg':'#aa3388',
            \                 'ctermfg':'red' } }

endfunction


"" Utl
let g:utl_cfg_hdl_scm_http="silent !chromium-browser '%u#%f' &"

"" YankRing
nnoremap <silent> <F12> :YRShow<cr>

"" CtrlP
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'

let g:ctrlp_custom_ignore = '\.git$\|\.hg$\|\.svn$'
" let g:ctrlp_custom_ignore = {
"   \ 'dir':  '\.git$\|\.hg$\|\.svn$',
"   \ 'file': '\.exe$\|\.so$\|\.dll$',
"   \ 'link': 'some_bad_symbolic_links',
"   \ }

"" SuperTab
"This doesn't work for console version?:
"let g:SuperTabMappingForward = '<c-space>'
"let g:SuperTabMappingBackward = '<s-c-space>'
let g:SuperTabMappingForward = '<nul>'
let g:SuperTabMappingBackward = '<s-nul>'


""" Airline
set laststatus=2
let g:airline_enable_syntastic=1
let g:airline_theme='badwolf'

" unicode symbols
let g:airline_left_sep = '»'
let g:airline_left_sep = '▶'
let g:airline_right_sep = '«'
let g:airline_right_sep = '◀'
let g:airline_linecolumn_prefix = '␊ '
let g:airline_linecolumn_prefix = '␤ '
let g:airline_linecolumn_prefix = '¶ '
let g:airline_fugitive_prefix = '⎇ '
let g:airline_paste_symbol = 'ρ'
let g:airline_paste_symbol = 'Þ'
let g:airline_paste_symbol = '∥'



"" NERDTree
map <leader>nn :NERDTreeToggle<cr>
map <leader>nb :NERDTreeFromBookmark
map <leader>nf :NERDTreeFind<cr>

"" Rainbow parentheses
map <leader>r :RainbowParenthesesToggle<cr>
au VimEnter * RainbowParenthesesToggle

"" autoreload vimrc - you might want to change that line
autocmd! bufwritepost vimrc source ~/dotfiles/vim/vimrc

"" XNS
au BufNewFile,BufRead xns.in set filetype=xns

"" Fortran
let fortran_dialect = 'f90'
let fortran_fixed_source = 0
let fortran_free_source = 1
hi link fortranTab NONE
au BufRead,BufNewFile *.F set noexpandtab
" au BufRead,BufNewFile *.F set softtabstop=0
au BufRead,BufNewFile *.F set shiftwidth=0
" https://gist.github.com/1470884
" https://gist.github.com/1471147
" https://gist.github.com/2424873
"" last/newest one is used here

"" Everything else:
":autocmd BufReadPost * :DetectIndent
autocmd BufNewFile,BufRead *.ino setlocal ft=arduino

" Autoremove white trailing white space:
autocmd BufWritePre * :%s/\s\+$//e

"" Remap vim's autocompletion to Tab-Key:
"Use TAB to complete when typing words, else inserts TABs as usual.
"Uses dictionary and source files to find matching words to complete.

"See help completion for source,
"Note: usual completion is on <C-n> but more trouble to press all the time.
"Never type the same word twice and maybe learn a new spellings!
"Use the Linux dictionary when spelling is in doubt.
"Window users can copy the file to their machine.
function! Tab_Or_Complete()
  if col('.')>1 && strpart( getline('.'), col('.')-2, 3 ) =~ '^\w'
    return "\<C-N>"
  else
    return "\<Tab>"
  endif
endfunction
:inoremap <Tab> <C-R>=Tab_Or_Complete()<CR>
:set dictionary="/usr/dict/words"

source ~/.vimrc_local
